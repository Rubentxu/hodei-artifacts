//! Tests unitarios de MongoArtifactRepository usando mocks in-memory.
//! Requiere ejecutar con la feature: `cargo test -p artifact --features test-internals`
//!
//! Justificación:
//! - Verifica mapping (Artifact <-> ArtifactDocument) y lógica duplicate sin levantar Mongo real.
//! - Aísla comportamiento frente a errores de escritura (clave duplicada).
//!
//! NOTA: Estos tests dependen de items expuestos únicamente bajo la feature `test-internals`
//! (ArtifactDocument, ArtifactCollectionLike, DuplicateKeyDetector, with_components).

#![cfg(feature = "test-internals")]

use artifact::infrastructure::persistence::mongo_artifact_repository::{
    MongoArtifactRepository,
    ArtifactDocument,
    ArtifactCollectionLike,
    DuplicateKeyDetector,
};
use infra_mongo::MongoClientFactory;
use shared::{ArtifactId, RepositoryId, IsoTimestamp, UserId};
use artifact::domain::model::{Artifact, ArtifactChecksum, ArtifactVersion};
use artifact::error::ArtifactError;
use async_trait::async_trait;
use chrono::Utc;
use std::sync::{Arc, Mutex};

#[derive(Debug)]
struct DuplicateErr;

impl std::fmt::Display for DuplicateErr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "duplicate")
    }
}

impl std::error::Error for DuplicateErr {}

struct MockDuplicateKeyDetector;
impl DuplicateKeyDetector for MockDuplicateKeyDetector {
    fn is_duplicate(&self, err: &(dyn std::error::Error + 'static)) -> bool {
        err.downcast_ref::<DuplicateErr>().is_some()
    }
}

#[derive(Clone)]
struct MockCollection {
    docs: Arc<Mutex<Vec<ArtifactDocument>>>,
}

impl MockCollection {
    fn new() -> Self {
        Self { docs: Arc::new(Mutex::new(Vec::new())) }
    }
}

#[async_trait]
impl ArtifactCollectionLike for MockCollection {
    async fn insert_one(&self, doc: ArtifactDocument) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let mut guard = self.docs.lock().unwrap();
        // Simular índice único repository_id + checksum
        if guard.iter().any(|d| d.repository_id == doc.repository_id && d.checksum == doc.checksum) {
            return Err(Box::new(DuplicateErr));
        }
        guard.push(doc);
        Ok(())
    }

    async fn find_one(&self, filter: mongodb::bson::Document) -> Result<Option<ArtifactDocument>, Box<dyn std::error::Error + Send + Sync>> {
        let repo_id = filter.get_str("repository_id").ok().map(|s| s.to_string());
        let checksum = filter.get_str("checksum").ok().map(|s| s.to_string());
        let id = filter.get_str("_id").ok().map(|s| s.to_string());
        let guard = self.docs.lock().unwrap();
        let found = guard.iter().find(|d| {
            if let Some(i) = &id {
                return &d._id == i;
            }
            if let (Some(r), Some(c)) = (&repo_id, &checksum) {
                return &d.repository_id == r && &d.checksum == c;
            }
            false
        }).cloned();
        Ok(found)
    }

    async fn create_index(&self, _model: mongodb::IndexModel) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // No-op en mock
        Ok(())
    }
}

fn sample_artifact(repo: RepositoryId) -> Artifact {
    Artifact {
        id: ArtifactId(uuid::Uuid::new_v4()),
        repository_id: repo,
        version: ArtifactVersion("1.0.0".into()),
        file_name: "file.bin".into(),
        size_bytes: 1234,
        checksum: ArtifactChecksum("abc123".into()),
        created_at: IsoTimestamp(Utc::now()),
        created_by: UserId(uuid::Uuid::new_v4()),
        coordinates: None,
    }
}

fn factory_stub() -> Arc<MongoClientFactory> {
    // No se usará (colección mock), config mínima ficticia.
    let cfg = infra_mongo::config::MongoConfig {
        uri: "mongodb://unused".into(),
        database: "unused".into(),
        min_pool_size: None,
        max_pool_size: None,
        app_name: None,
        tls: None,
    };
    Arc::new(MongoClientFactory::new(cfg))
}

#[tokio::test]
async fn save_and_get_roundtrip() {
    let repo_id = RepositoryId(uuid::Uuid::new_v4());
    let art = sample_artifact(repo_id);
    let collection = Arc::new(MockCollection::new());
    let detector = Arc::new(MockDuplicateKeyDetector);
    let repo = MongoArtifactRepository::with_components(factory_stub(), detector, collection.clone());

    repo.save(&art).await.expect("save ok");
    let fetched = repo.get(&art.id).await.expect("get ok").expect("found");
    assert_eq!(fetched.id.0, art.id.0);
    assert_eq!(fetched.checksum.0, art.checksum.0);
}

#[tokio::test]
async fn save_duplicate_maps_to_duplicate_error() {
    let repo_id = RepositoryId(uuid::Uuid::new_v4());
    let art1 = sample_artifact(repo_id);
    let mut art2 = art1.clone();
    art2.id = ArtifactId(uuid::Uuid::new_v4()); // distinto id, misma (repo,checksum)

    let collection = Arc::new(MockCollection::new());
    let detector = Arc::new(MockDuplicateKeyDetector);
    let repo = MongoArtifactRepository::with_components(factory_stub(), detector, collection.clone());

    repo.save(&art1).await.expect("first ok");
    let err = repo.save(&art2).await.expect_err("duplicate expected");
    match err {
        ArtifactError::Duplicate => {},
        other => panic!("esperado Duplicate, obtuve {other:?}"),
    }
}

#[tokio::test]
async fn find_by_repo_and_checksum_returns_document() {
    let repo_id = RepositoryId(uuid::Uuid::new_v4());
    let art = sample_artifact(repo_id);
    let collection = Arc::new(MockCollection::new());
    let detector = Arc::new(MockDuplicateKeyDetector);
    let repo = MongoArtifactRepository::with_components(factory_stub(), detector, collection.clone());
    repo.save(&art).await.unwrap();

    let found = repo.find_by_repo_and_checksum(&repo_id, &art.checksum).await.unwrap();
    assert!(found.is_some());
    assert_eq!(found.unwrap().checksum.0, art.checksum.0);
}

// (Posible test adicional futuro) verify ensure_indexes no falla sobre mock (no necesario ahora).