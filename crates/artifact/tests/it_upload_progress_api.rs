use std::sync::Arc;\nuse axum::{\n    body::Body,\n    http::{Request, StatusCode},\n    routing::get,\n    Router,\n};\nuse tempfile::TempDir;\nuse tower::ServiceExt;\n\nuse artifact::features::upload_artifact::{\n    upload_progress::{\n        api::{UploadProgressApi},\n        service::UploadProgressService,\n        ports::{ProgressStorage, ProgressEventPublisher, RealtimeNotifier},\n    },\n    adapter::LocalFsChunkedUploadStorage,\n    ports::ChunkedUploadStorage,\n};\nuse artifact::features::upload_artifact::upload_progress::dto::{UploadStatus, UpdateProgressCommand};\n\n// Mocks para las pruebas de la API\n#[derive(Default)]\nstruct MockProgressStorage {\n    sessions: std::sync::Mutex<std::collections::HashMap<String, artifact::features::upload_artifact::upload_progress::dto::UploadProgress>>,\n}\n\n#[async_trait::async_trait]\nimpl ProgressStorage for MockProgressStorage {\n    async fn create_session(&self, progress: artifact::features::upload_artifact::upload_progress::dto::UploadProgress) -> Result<(), artifact::features::upload_artifact::upload_progress::ports::ProgressError> {\n        self.sessions.lock().unwrap().insert(progress.upload_id.clone(), progress);\n        Ok(())\n    }\n\n    async fn get_progress(&self, upload_id: &str) -> Result<artifact::features::upload_artifact::upload_progress::dto::UploadProgress, artifact::features::upload_artifact::upload_progress::ports::ProgressError> {\n        self.sessions.lock().unwrap().get(upload_id)\n            .cloned()\n            .ok_or_else(|| artifact::features::upload_artifact::upload_progress::ports::ProgressError::SessionNotFound(upload_id.to_string()))\n    }\n\n    async fn update_progress(&self, command: artifact::features::upload_artifact::upload_progress::dto::UpdateProgressCommand) -> Result<artifact::features::upload_artifact::upload_progress::dto::UploadProgress, artifact::features::upload_artifact::upload_progress::ports::ProgressError> {\n        let mut sessions = self.sessions.lock().unwrap();\n        let progress = sessions.get_mut(&command.upload_id)\n            .ok_or_else(|| artifact::features::upload_artifact::upload_progress::ports::ProgressError::SessionNotFound(command.upload_id.clone()))?;\n\n        progress.update(command.bytes_transferred, command.total_bytes);\n        progress.status = command.status;\n        \n        Ok(progress.clone())\n    }\n\n    async fn delete_session(&self, upload_id: &str) -> Result<(), artifact::features::upload_artifact::upload_progress::ports::ProgressError> {\n        self.sessions.lock().unwrap().remove(upload_id);\n        Ok(())\n    }\n\n    async fn list_sessions(&self) -> Result<Vec<artifact::features::upload_artifact::upload_progress::dto::UploadProgress>, artifact::features::upload_artifact::upload_progress::ports::ProgressError> {\n        Ok(self.sessions.lock().unwrap().values().cloned().collect())\n    }\n}\n\n#[derive(Default)]\nstruct MockEventPublisher {\n    published_events: std::sync::Mutex<Vec<String>>,\n}\n\n#[async_trait::async_trait]\nimpl ProgressEventPublisher for MockEventPublisher {\n    async fn publish_progress_update(&self, _progress: &artifact::features::upload_artifact::upload_progress::dto::UploadProgress) -> Result<(), artifact::features::upload_artifact::upload_progress::ports::ProgressError> {\n        self.published_events.lock().unwrap().push(\"progress_update\".to_string());\n        Ok(())\n    }\n\n    async fn publish_upload_completed(&self, upload_id: &str) -> Result<(), artifact::features::upload_artifact::upload_progress::ports::ProgressError> {\n        self.published_events.lock().unwrap().push(format!(\"completed_{}\", upload_id));\n        Ok(())\n    }\n\n    async fn publish_upload_failed(&self, upload_id: &str, _error: &str) -> Result<(), artifact::features::upload_artifact::upload_progress::ports::ProgressError> {\n        self.published_events.lock().unwrap().push(format!(\"failed_{}\", upload_id));\n        Ok(())\n    }\n}\n\n#[derive(Default)]\nstruct MockRealtimeNotifier {\n    notifications: std::sync::Mutex<Vec<String>>,\n    subscriptions: std::sync::Mutex<Vec<(String, String)>>,\n}\n\n#[async_trait::async_trait]\nimpl RealtimeNotifier for MockRealtimeNotifier {\n    async fn notify_progress_update(&self, progress: &artifact::features::upload_artifact::upload_progress::dto::UploadProgress) -> Result<(), artifact::features::upload_artifact::upload_progress::ports::ProgressError> {\n        self.notifications.lock().unwrap().push(format!(\"notify_{}_{}\", progress.upload_id, progress.percentage));\n        Ok(())\n    }\n\n    async fn subscribe(&self, upload_id: &str, client_id: &str) -> Result<(), artifact::features::upload_artifact::upload_progress::ports::ProgressError> {\n        self.subscriptions.lock().unwrap().push((upload_id.to_string(), client_id.to_string()));\n        Ok(())\n    }\n\n    async fn unsubscribe(&self, client_id: &str) -> Result<(), artifact::features::upload_artifact::upload_progress::ports::ProgressError> {\n        let mut subscriptions = self.subscriptions.lock().unwrap();\n        subscriptions.retain(|(_, cid)| cid != client_id);\n        Ok(())\n    }\n}\n\n// Mock de identidad de usuario para las pruebas\n#[derive(Clone)]\nstruct MockUserIdentity {\n    user_id: String,\n}\n\nimpl MockUserIdentity {\n    fn new(user_id: &str) -> Self {\n        Self { user_id: user_id.to_string() }\n    }\n}\n\n// Implementar el extractor para el mock\nimpl axum::extract::FromRequestParts<()> for MockUserIdentity {\n    type Rejection = std::convert::Infallible;\n\n    async fn from_request_parts(\n        _parts: &mut axum::http::request::Parts,\n        _state: &()\n    ) -> Result<Self, Self::Rejection> {\n        Ok(MockUserIdentity::new(\"test-user\"))\n    }\n}\n\n#[tokio::test]\nasync fn test_get_received_chunks_api_happy_path() -> Result<(), Box<dyn std::error::Error>> {\n    let storage = Arc::new(MockProgressStorage::default());\n    let event_publisher = Arc::new(MockEventPublisher::default());\n    let realtime_notifier = Arc::new(MockRealtimeNotifier::default());\n    \n    // Crear almacenamiento de chunks real\n    let temp_dir = TempDir::new()?;\n    let chunked_storage = Arc::new(LocalFsChunkedUploadStorage::new(temp_dir.path().to_path_buf()));\n    \n    let service = UploadProgressService::new_with_chunked_storage(\n        storage.clone(),\n        event_publisher,\n        realtime_notifier,\n        chunked_storage.clone(),\n    );\n    let api = UploadProgressApi::new(service);\n    \n    // Crear sesión de prueba\n    api.service.create_session(\"test-user-chunks-123\".to_string(), 3 * 1024 * 1024).await.unwrap();\n    \n    // Guardar algunos chunks\n    let chunk1_data = bytes::Bytes::from(\"Test chunk 1 data\");\n    let chunk2_data = bytes::Bytes::from(\"Test chunk 2 data\");\n    \n    chunked_storage.save_chunk(\"test-user-chunks-123\", 1, chunk1_data).await?;\n    chunked_storage.save_chunk(\"test-user-chunks-123\", 2, chunk2_data).await?;\n    \n    // Crear router con el endpoint\n    let app = Router::new()\n        .route(\"/uploads/:upload_id/chunks\", get(UploadProgressApi::get_received_chunks))\n        .with_state(api);\n    \n    // Hacer la petición\n    let response = app\n        .oneshot(\n            Request::builder()\n                .method(axum::http::Method::GET)\n                .uri(\"/uploads/test-user-chunks-123/chunks\")\n                .body(Body::empty())?,\n        )\n        .await?;\n    \n    assert_eq!(response.status(), StatusCode::OK);\n    \n    let body = hyper::body::to_bytes(response.into_body()).await?;\n    let response_text = std::str::from_utf8(&body)?;\n    assert!(response_text.contains(\"test-user-chunks-123\"));\n    assert!(response_text.contains(\"\\\"received_chunk_numbers\\\":[1,2]\"));\n    \n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_get_received_chunks_api_not_found() -> Result<(), Box<dyn std::error::Error>> {\n    let storage = Arc::new(MockProgressStorage::default());\n    let event_publisher = Arc::new(MockEventPublisher::default());\n    let realtime_notifier = Arc::new(MockRealtimeNotifier::default());\n    let chunked_storage = Arc::new(LocalFsChunkedUploadStorage::new(TempDir::new()?.path().to_path_buf()));\n    \n    let service = UploadProgressService::new_with_chunked_storage(\n        storage.clone(),\n        event_publisher,\n        realtime_notifier,\n        chunked_storage,\n    );\n    let api = UploadProgressApi::new(service);\n    \n    // Crear router con el endpoint\n    let app = Router::new()\n        .route(\"/uploads/:upload_id/chunks\", get(UploadProgressApi::get_received_chunks))\n        .with_state(api);\n    \n    // Hacer la petición para un upload que no existe\n    let response = app\n        .oneshot(\n            Request::builder()\n                .method(axum::http::Method::GET)\n                .uri(\"/uploads/non-existent-upload/chunks\")\n                .body(Body::empty())?,\n        )\n        .await?;\n    \n    assert_eq!(response.status(), StatusCode::NOT_FOUND);\n    \n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_get_received_chunks_api_unauthorized() -> Result<(), Box<dyn std::error::Error>> {\n    let storage = Arc::new(MockProgressStorage::default());\n    let event_publisher = Arc::new(MockEventPublisher::default());\n    let realtime_notifier = Arc::new(MockRealtimeNotifier::default());\n    let chunked_storage = Arc::new(LocalFsChunkedUploadStorage::new(TempDir::new()?.path().to_path_buf()));\n    \n    let service = UploadProgressService::new_with_chunked_storage(\n        storage.clone(),\n        event_publisher,\n        realtime_notifier,\n        chunked_storage,\n    );\n    let api = UploadProgressApi::new(service);\n    \n    // Crear sesión de prueba con un usuario diferente\n    api.service.create_session(\"other-user-chunks-456\".to_string(), 1000).await.unwrap();\n    \n    // Crear router con el endpoint\n    let app = Router::new()\n        .route(\"/uploads/:upload_id/chunks\", get(UploadProgressApi::get_received_chunks))\n        .with_state(api);\n    \n    // Hacer la petición para un upload de otro usuario\n    let response = app\n        .oneshot(\n            Request::builder()\n                .method(axum::http::Method::GET)\n                .uri(\"/uploads/other-user-chunks-456/chunks\")\n                .body(Body::empty())?,\n        )\n        .await?;\n    \n    // Con la implementación actual de autorización, esto devolverá FORBIDDEN\n    // En una implementación real, se verificaría contra una base de datos\n    assert_eq!(response.status(), StatusCode::FORBIDDEN);\n    \n    Ok(())\n}