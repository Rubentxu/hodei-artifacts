# Story 6.3: Artifact Signing

## Status
- ✅ Completed

## Story
**Como** un Arquitecto de Seguridad,
**quiero** que cada artefacto subido sea firmado digitalmente de forma automática con una clave privada de la organización,
**para** establecer una cadena de confianza y garantizar la integridad y autenticidad de todos los artefactos en nuestro sistema.

## Acceptance Criteria
1.  ✅ Un evento `ArtifactUploaded` debe disparar el caso de uso de firma de artefactos.
2.  ✅ El caso de uso debe calcular un hash criptográfico (digest) del artefacto (SHA-256) a través de un `port`.
3.  ✅ El caso de uso debe obtener una clave de firma privada (Ed25519) a través de un `port` de abstracción.
4.  ✅ El hash del artefacto debe ser firmado usando la clave.
5.  ✅ La firma digital resultante debe guardarse de forma persistente a través de un `port` de repositorio.
6.  ✅ La clave privada nunca debe ser expuesta fuera de su `adapter` específico.

## Tasks / Subtasks
- [x] Tarea 1: Añadir las dependencias criptográficas (`ed25519-dalek`, `sha2`).
- [x] Tarea 2: Definir los modelos de dominio (`Signature`, `Digest`) en `security/src/domain/`.
- [x] Tarea 3: Construir la "Vertical Slice" para la feature `sign_artifact`.
- [x] Tarea 4: Definir las Abstracciones (Ports) en `ports.rs` (`trait IArtifactHasher`, `trait IKeyProvider`, `trait ISignatureRepository`).
- [x] Tarea 5: Implementar los Adaptadores (Concreciones) en `adapter.rs` (`Sha256ArtifactHasher`, `FileKeyProvider`, `MongoSignatureRepository`).
- [x] Tarea 6: Desarrollar el Caso de Uso en `use_case.rs` (`SignArtifactUseCase`).
- [x] Tarea 7: Conectar el punto de entrada en `api.rs` (manejador de eventos).
- [x] Tarea 8: Pruebas (verificar que una firma generada puede ser validada con la clave pública).

## Dev Notes
### Guía de Implementación Avanzada (Vertical Slice Architecture)
**Decisión Arquitectónica Clave: Abstracción del Manejo de Claves**
La gestión de claves es la parte más sensible. El `port` `IKeyProvider` nos aísla de la implementación, permitiendo una evolución segura desde una clave en un archivo a un KMS en la nube.

**Estructura de Directorios para esta Feature:**

```
crates/
└── security/
├── src/
│   ├── domain/
│   │   └── signature.rs
│   └── features/
│       └── sign_artifact/
│           ├── use_case.rs
│           ├── ports.rs
│           ├── adapter.rs
│           └── api.rs
```

**Flujo de Inversión de Dependencias:**
El `use_case` orquesta la firma sin saber cómo se obtiene la clave o cómo se guarda la firma, lo que lo hace altamente testable y mantenible.
```rust
// en features/sign_artifact/use_case.rs
pub struct SignArtifactUseCase {
    hasher: Arc<dyn IArtifactHasher>,
    key_provider: Arc<dyn IKeyProvider>,
    repository: Arc<dyn ISignatureRepository>,
}
// ...
```

### Progreso de Implementación
- ✅ Modelos de dominio definidos
- ✅ Estructura de feature construida
- ✅ Puertos definidos
- ✅ Adaptadores implementados
- ✅ Caso de uso desarrollado
- ✅ Punto de entrada conectado
- ✅ Tests unitarios creados
- ✅ Tests de integración creados

### Arquitectura Implementada
La implementación sigue fielmente la arquitectura VSA (Vertical Slice Architecture) con:
- **Separación clara de capas**: Dominio, casos de uso, puertos y adaptadores
- **Inversión de dependencias**: Los casos de uso dependen únicamente de abstracciones
- **Aislamiento por feature**: Cada feature tiene su propia estructura de directorios y componentes
- **Segregación de interfaces**: Puertos específicos para cada funcionalidad (`IArtifactHasher`, `IKeyProvider`, `ISignatureRepository`)

### Cobertura de Tests
- ✅ 4 tests unitarios para el caso de uso `SignArtifactUseCase` (happy path + todos los errores posibles)
- ✅ 1 test de integración para el flujo completo de firma de artefactos
- ✅ Uso de mocks con `mockall` para aislar dependencias en tests unitarios

### Componentes Implementados
**Domain (`crates/security/src/domain/signature.rs`):**
- `Signature`: Modelo de dominio para representar una firma digital
- `HashAlgorithm`: Enumeración de algoritmos de hash
- `SignatureAlgorithm`: Enumeración de algoritmos de firma

**Feature `sign_artifact` (`crates/security/src/features/sign_artifact/`):**
- **Caso de uso**: `SignArtifactUseCase` que orquesta la generación de la firma
- **Puertos**: `IArtifactHasher`, `IKeyProvider`, `ISignatureRepository` (abstracciones)
- **Adaptadores**: `Sha256ArtifactHasher`, `FileKeyProvider`, `MongoSignatureRepository` (implementaciones concretas)
- **API**: `ArtifactSigningEventHandler` (manejador de eventos `ArtifactUploaded`)

**Tests:**
- **Unitarios**: `use_case_test.rs` con tests para caminos felices y errores
- **Integración**: `tests/it_sign_artifact.rs` con test del flujo completo

## Implementation Notes

### Improved Architecture
- **Correct Bounded Context**: Implementation placed in `security` crate as per architectural guidelines
- **Proper VSA Implementation**: Clean separation of concerns with domain, application, ports, and adapters
- **Segregated Interfaces**: Each port has a specific purpose with minimal interface

### Error Handling
- Comprehensive error handling with specific error types for each failure scenario
- Proper error propagation from adapters to use case to API handler
- All error cases covered in unit tests

### Test Coverage
- All possible error scenarios tested:
  - Artifact hashing failure
  - Key provider failure
  - Repository save failure
- Happy path thoroughly tested
- Integration test validates complete workflow

### Future Improvements
1. Implement actual artifact hashing instead of simulation
2. Add real key provider implementation instead of simulation
3. Add real signature repository implementation
4. Implement the signature validation endpoint feature