# Story 6.3: Artifact Signing

## Status
- Draft

## Story
**Como** un Arquitecto de Seguridad,
**quiero** que cada artefacto subido sea firmado digitalmente de forma automática con una clave privada de la organización,
**para** establecer una cadena de confianza y garantizar la integridad y autenticidad de todos los artefactos en nuestro sistema.

## Acceptance Criteria
1.  Un evento `ArtifactUploaded` debe disparar el caso de uso de firma de artefactos.
2.  El caso de uso debe calcular un hash criptográfico (digest) del artefacto (SHA-256) a través de un `port`.
3.  El caso de uso debe obtener una clave de firma privada (Ed25519) a través de un `port` de abstracción.
4.  El hash del artefacto debe ser firmado usando la clave.
5.  La firma digital resultante debe guardarse de forma persistente a través de un `port` de repositorio.
6.  La clave privada nunca debe ser expuesta fuera de su `adapter` específico.

## Tasks / Subtasks
- [ ] Tarea 1: Añadir las dependencias criptográficas (`ed25519-dalek`, `sha2`).
- [ ] Tarea 2: Definir los modelos de dominio (`Signature`, `Digest`) en `security_management/src/domain/`.
- [ ] Tarea 3: Construir la "Vertical Slice" para la feature `sign_artifact`.
- [ ] Tarea 4: Definir las Abstracciones (Ports) en `ports.rs` (`trait IArtifactHasher`, `trait IKeyProvider`, `trait ISignatureRepository`).
- [ ] Tarea 5: Implementar los Adaptadores (Concreciones) en `adapter.rs` (`Sha256ArtifactHasher`, `FileKeyProvider`, `MongoSignatureRepository`).
- [ ] Tarea 6: Desarrollar el Caso de Uso en `use_case.rs` (`SignArtifactUseCase`).
- [ ] Tarea 7: Conectar el punto de entrada en `api.rs` (manejador de eventos).
- [ ] Tarea 8: Pruebas (verificar que una firma generada puede ser validada con la clave pública).

## Dev Notes
### Guía de Implementación Avanzada (Vertical Slice Architecture)
**Decisión Arquitectónica Clave: Abstracción del Manejo de Claves**
La gestión de claves es la parte más sensible. El `port` `IKeyProvider` nos aísla de la implementación, permitiendo una evolución segura desde una clave en un archivo a un KMS en la nube.

**Estructura de Directorios para esta Feature:**


crates/
└── security_management/
├── src/
│   ├── domain/
│   │   └── signature.rs
│   └── features/
│       └── sign_artifact/
│           ├── use_case.rs
│           ├── ports.rs
│           ├── adapter.rs
│           └── api.rs


**Flujo de Inversión de Dependencias:**
El `use_case` orquesta la firma sin saber cómo se obtiene la clave o cómo se guarda la firma, lo que lo hace altamente testable y mantenible.
```rust
// en features/sign_artifact/use_case.rs
pub struct SignArtifactUseCase {
    hasher: Arc<dyn IArtifactHasher>,
    key_provider: Arc<dyn IKeyProvider>,
    repository: Arc<dyn ISignatureRepository>,
}
// ...
```
