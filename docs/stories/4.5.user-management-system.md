# Historia 4.5: User Management System

## Estado
- **Borrador (Draft)**

## Historia
**Como** administrador del sistema,
**necesito** un sistema para gestionar usuarios y sus atributos (crear, leer, actualizar, eliminar),
**para que** pueda controlar quién tiene acceso al sistema y definir políticas de autorización basadas en sus características.

## Criterios de Aceptación
1.  Se ha definido un modelo de datos para la entidad `User`, que incluye atributos clave para ABAC como `id`, `email`, `status` (p. ej., "activo", "suspendido"), y una lista de membresías a grupos.
2.  Existen endpoints de API para las operaciones CRUD sobre los usuarios.
3.  Se publica un evento `UserCreated` cuando se crea un nuevo usuario.
4.  Se publica un evento `UserUpdated` (y/o `UserAttributesChanged`) cuando se modifican los atributos de un usuario.
5.  Se publica un evento `UserDeleted` cuando se elimina un usuario.
6.  El sistema proporciona un mecanismo para almacenar de forma persistente a los usuarios y sus atributos.
7.  La implementación del modelo `User` es totalmente compatible con el trait `CedarEntity` definido en la historia `4.1`, permitiendo su uso directo en las evaluaciones de políticas.

## Tareas / Subtareas
- [ ] **Tarea 1: Definir el Modelo y Repositorio de Usuario** (AC: #1, #6)
    - [ ] Definir la estructura `User` en el código, incluyendo campos como `id`, `email`, `status` y `group_memberships`.
    - [ ] Crear un trait `UserRepository` que defina las operaciones CRUD asíncronas.
    - [ ] Implementar una versión inicial en memoria, `InMemoryUserRepository`, para desarrollo y pruebas.
- [ ] **Tarea 2: Definir Endpoints de la API**
    - [ ] Añadir los endpoints CRUD para `/api/v1/users` a la especificación OpenAPI del proyecto.
- [ ] **Tarea 3: Implementar los Handlers de la API** (AC: #2)
    - [ ] Implementar los handlers para `POST`, `GET`, `PUT`, y `DELETE` para la gestión de usuarios.
    - [ ] Conectar los handlers con la implementación del `UserRepository`.
- [ ] **Tarea 4: Publicar Eventos de Dominio** (AC: #3, #4, #5)
    - [ ] Integrar la publicación de eventos (`UserCreated`, `UserUpdated`, `UserDeleted`) en los handlers de la API tras cada operación exitosa.
- [ ] **Tarea 5: Validar la Integración con Cedar** (AC: #7)
    - [ ] Asegurarse de que la estructura `User` implementa correctamente el trait `CedarEntity`.
    - [ ] Añadir pruebas que verifiquen que una instancia de `User` se convierte correctamente en una `cedar_policy::Entity` con todos sus atributos.
- [ ] **Tarea 6: Añadir Pruebas**
    - [ ] Escribir pruebas unitarias para la implementación del `UserRepository`.
    - [ ] Escribir pruebas de integración para los endpoints de la API de usuarios.

## Notas para el Desarrollador
Esta historia crea la gestión fundamental de la entidad `Principal` más importante del sistema: el usuario. Los atributos definidos en el modelo `User` serán la base para el Control de Acceso Basado en Atributos (ABAC).

### Modelo de Usuario para ABAC
* El modelo `User` es crítico. Atributos como `status` o `group_memberships` serán utilizados directamente en las políticas de Cedar para tomar decisiones de autorización. Por ejemplo: `permit (principal, action, resource) when { principal.status == "active" };`
* La implementación debe ser compatible con el patrón de mapeo a `CedarEntity` ya definido en la historia `4.1` y en la investigación técnica.
    ```rust
    // Recordatorio del patrón de mapeo para la entidad User
    // Fuente: Investigación Técnica de la Épica E4
    impl CedarEntity for User {
        fn to_entity(&self) -> cedar_policy::Entity {
            let mut attributes = HashMap::new();
            
            attributes.insert("type".to_string(), cedar_policy::Value::String("user".to_string()));
            attributes.insert("email".to_string(), cedar_policy::Value::String(self.email.clone()));
            attributes.insert("status".to_string(), cedar_policy::Value::String(self.status.to_string()));
            
            // Mapear membresías de grupo
            let groups: Vec<cedar_policy::Value> = self.group_memberships
                .iter()
                .map(|hrn| cedar_policy::Value::Entity(hrn.to_entity_uid()))
                .collect();
            
            attributes.insert("memberOf".to_string(), cedar_policy::Value::Set(groups));
            
            cedar_policy::Entity::new(self.hrn.to_entity_uid(), attributes)
        }
    }
    ```

### Eventos de Atributos
* Es importante emitir eventos cuando los atributos de un usuario cambian (`UserAttributesChanged`). Esto permitirá que sistemas como la caché de decisiones (`AccessDecisionCache`) sepan que deben invalidar las decisiones relacionadas con ese usuario, ya que sus permisos podrían haber cambiado.

## Pruebas
* Las pruebas de integración deben verificar el ciclo de vida completo: crear un usuario vía API, leerlo para confirmar su estado, actualizarlo y finalmente eliminarlo, comprobando que en cada paso se emiten los eventos correctos.

## Registro de Cambios
| Fecha | Versión | Descripción | Autor |
| :--- | :--- | :--- | :--- |
| 2025-09-10 | 1.0 | Borrador inicial | sm (Bob) |