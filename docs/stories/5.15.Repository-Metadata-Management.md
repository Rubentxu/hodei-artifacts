# Story 5.15: Repository Metadata Management

## Status
- Draft

## Story
**Como** un Ingeniero de DevOps,
**quiero** adjuntar metadatos personalizados (pares clave-valor) a un repositorio,
**para** poder etiquetar repositorios con información relevante para mis flujos de trabajo de CI/CD, como el ID del commit de Git, el estado de una quality gate, o el entorno de despliegue.

## Acceptance Criteria
1.  Un usuario puede añadir o actualizar múltiples pares clave-valor en los metadatos de un repositorio mediante una única petición `PATCH` a la API.
2.  Un usuario puede eliminar una clave específica de los metadatos de un repositorio.
3.  Los metadatos personalizados se pueden recuperar a través de un endpoint específico en la API.
4.  La consulta general de la información de un repositorio también debe incluir sus metadatos personalizados.
5.  El sistema debe permitir que los valores de los metadatos sean de tipos JSON variados (string, número, booleano, objeto, array).
6.  La gestión de metadatos personalizados no debe interferir con la configuración interna del repositorio gestionada por el sistema.

## Tasks / Subtasks
- [ ] Tarea 1: Actualizar el modelo de datos del repositorio. (AC: 5, 6)
    - [ ] Subtarea 1.1: Añadir un campo `custom_metadata: Bson::Document` al esquema de la colección `repositories` en MongoDB.
    - [ ] Subtarea 1.2: En la struct `Repository` de Rust, añadir el campo `custom_metadata: HashMap<String, serde_json::Value>`.
- [ ] Tarea 2: Implementar el servicio para la manipulación de metadatos.
    - [ ] Subtarea 2.1: En el `RepositoryService`, crear una función `update_metadata` que acepte un `repo_id` y un `HashMap` con los nuevos valores.
    - [ ] Subtarea 2.2: La implementación debe usar operaciones atómicas de MongoDB (`$set` y `$unset` con notación de punto) para modificar claves individuales sin leer y reescribir todo el objeto de metadatos.
- [ ] Tarea 3: Exponer la funcionalidad en la API REST. (AC: 1, 2, 3)
    - [ ] Subtarea 3.1: Crear un endpoint `PATCH /api/v1/repositories/{repo_name}/metadata` que reciba un objeto JSON y lo fusione con los metadatos existentes.
    - [ ] Subtarea 3.2: Crear un endpoint `DELETE /api/v1/repositories/{repo_name}/metadata/{key}` para eliminar una clave específica.
    - [ ] Subtarea 3.3: Crear un endpoint `GET /api/v1/repositories/{repo_name}/metadata` para devolver únicamente el objeto de metadatos personalizados.
- [ ] Tarea 4: Integrar los metadatos en la respuesta del repositorio principal. (AC: 4)
    - [ ] Subtarea 4.1: Modificar el handler del endpoint `GET /api/v1/repositories/{repo_name}` para que la respuesta incluya el campo `custom_metadata`.
- [ ] Tarea 5: Pruebas.
    - [ ] Subtarea 5.1: Probar el flujo completo: añadir una clave con `PATCH`, verificar que aparece en `GET`, actualizarla, y finalmente eliminarla con `DELETE`.
    - [ ] Subtarea 5.2: Probar que se pueden guardar diferentes tipos de datos JSON, incluyendo objetos anidados.
    - [ ] Subtarea 5.3: Probar que un `PATCH` con una clave nula (`null`) la elimina efectivamente de los metadatos (o decidir si ese es el comportamiento deseado).

## Dev Notes

### Guía de Implementación y Contexto Arquitectónico

**Decisión Arquitectónica Clave: Almacenamiento Flexible y Modificación Atómica**
-   **Modelo de Datos**: Usar `HashMap<String, serde_json::Value>` en Rust es la mejor opción. Permite al usuario final enviar cualquier JSON válido como valor, ofreciendo máxima flexibilidad. En MongoDB, esto se almacena de forma natural como un sub-documento.
-   **Operaciones de API y Base de Datos**: Es fundamental usar `PATCH` para las actualizaciones parciales. Esto se traduce directamente en operaciones eficientes en MongoDB. En lugar de leer el documento, modificarlo en memoria y guardarlo (lo que podría causar una `race condition`), se deben usar operadores de actualización atómicos.

**Ejemplo de Implementación del Servicio (usando el driver de MongoDB para Rust):**
```rust
// En RepositoryService
async fn patch_metadata(
    &self,
    repo_name: &str,
    updates: HashMap<String, serde_json::Value>,
) -> Result<(), Error> {
    let collection = self.db.collection("repositories");

    // Construir el documento de actualización
    let mut update_doc = doc! {};
    for (key, value) in updates {
        let field_key = format!("custom_metadata.{}", key);
        if value.is_null() {
            // Si el valor es nulo, lo eliminamos con $unset
            if let Some(mut unset_doc) = update_doc.get_document_mut("$unset").ok() {
                unset_doc.insert(field_key, "");
            } else {
                update_doc.insert("$unset", doc! { field_key: "" });
            }
        } else {
            // Si tiene valor, lo añadimos/actualizamos con $set
            let bson_value = bson::to_bson(&value)?;
            if let Some(mut set_doc) = update_doc.get_document_mut("$set").ok() {
                set_doc.insert(field_key, bson_value);
            } else {
                update_doc.insert("$set", doc! { field_key: bson_value });
            }
        }
    }

    collection.update_one(doc! { "name": repo_name }, update_doc, None).await?;
    Ok(())
}