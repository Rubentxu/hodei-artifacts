# Story 5.12: Repository Health Checks

## Status
- Draft

## Story
**Como** un Ingeniero de Fiabilidad de Sitios (SRE),
**quiero** un endpoint de API que verifique la salud completa de un repositorio específico,
**para** poder integrarlo con nuestros sistemas de monitorización y alerting, y diagnosticar rápidamente problemas de conectividad o configuración.

## Acceptance Criteria
1.  Debe existir un endpoint de API `GET` para solicitar un informe de salud de un repositorio específico.
2.  Si el repositorio y todas sus dependencias están operativas, el endpoint debe devolver un código de estado `200 OK`.
3.  Si alguna de las dependencias críticas del repositorio falla, el endpoint debe devolver un `503 Service Unavailable`.
4.  El cuerpo de la respuesta debe ser un JSON que detalle el estado de cada componente verificado (ej: `database: "OK"`, `storage: "OK"`, `remote_url: "FAILED"`).
5.  Para un repositorio "hosted", las comprobaciones deben incluir la conectividad con la base de datos y el backend de almacenamiento.
6.  Para un repositorio "proxy", las comprobaciones deben incluir todo lo de un "hosted" y, adicionalmente, la conectividad con la URL del repositorio remoto.
7.  Cada comprobación individual debe tener un timeout agresivo (ej: < 2 segundos) para asegurar una respuesta rápida del endpoint de salud.

## Tasks / Subtasks
- [ ] Tarea 1: Diseñar un framework de health checks extensible. (AC: 4)
    - [ ] Subtarea 1.1: Definir un `trait HealthCheck` en Rust con una función `check(&self) -> Future<Output = HealthStatus>`.
    - [ ] Subtarea 1.2: Definir una struct `HealthStatus` que contenga un estado general (`OK` o `UNHEALTHY`) y un `HashMap<String, ComponentStatus>` para los detalles.
- [ ] Tarea 2: Implementar las comprobaciones de salud individuales. (AC: 5, 6, 7)
    - [ ] Subtarea 2.1: Crear una implementación `DatabaseHealthCheck` que ejecute un comando `ping` a MongoDB y controle el timeout.
    - [ ] Subtarea 2.2: Crear una implementación `StorageHealthCheck` que realice una operación ligera contra el bucket de S3 (ej: `HeadBucket`) y controle el timeout.
    - [ ] Subtarea 2.3: Crear una implementación `ProxyRemoteHealthCheck` que realice una petición `HEAD` a la URL remota del proxy y controle el timeout.
- [ ] Tarea 3: Implementar el servicio agregador de salud.
    - [ ] Subtarea 3.1: Crear un `RepositoryHealthService` que, dado un ID de repositorio, determine su tipo.
    - [ ] Subtarea 3.2: El servicio debe recolectar y ejecutar en paralelo (`futures::join!`) todas las comprobaciones aplicables al tipo de repositorio.
    - [ ] Subtarea 3.3: El servicio debe agregar los resultados en un único `HealthStatus` final. Si cualquier comprobación falla, el estado general es `UNHEALTHY`.
- [ ] Tarea 4: Exponer el servicio a través de la API. (AC: 1, 2, 3)
    - [ ] Subtarea 4.1: Crear el endpoint `GET /api/v1/repositories/{repo_name}/health`.
    - [ ] Subtarea 4.2: El endpoint llamará al `RepositoryHealthService` y mapeará el resultado a una respuesta HTTP con el código de estado y el cuerpo JSON correspondientes.
- [ ] Tarea 5: Pruebas de resiliencia.
    - [ ] Subtarea 5.1: Probar el caso "feliz": todas las dependencias funcionan y el endpoint devuelve 200 OK.
    - [ ] Subtarea 5.2: Probar los casos de fallo: usar mocks para simular que la base de datos no responde, que el bucket S3 es inaccesible o que la URL remota del proxy falla, y verificar que el endpoint devuelve 503 en cada caso con el detalle correcto en el cuerpo de la respuesta.

## Dev Notes

### Guía de Implementación y Contexto Arquitectónico

**Decisión Arquitectónica Clave: Sondas de "Readiness" vs. "Liveness"**
Este health check implementa una **sonda de preparación (Readiness Probe)**. Su propósito es indicar si la aplicación está lista para recibir tráfico. Es diferente de una **sonda de vida (Liveness Probe)**, que simplemente verifica si el proceso está corriendo. Una sonda de liveness podría ser un endpoint `/health/live` que siempre devuelve `200 OK`, mientras que la que implementamos aquí (`/health/ready` o simplemente `/health`) es más profunda.

**Implementación del Framework de Health Checks:**
Un patrón de diseño robusto y extensible es registrar los `HealthCheck`s en un gestor central. El servicio principal no conocerá los detalles de cada comprobación, simplemente las ejecutará todas.

```rust
// Ejemplo de la estructura de la respuesta JSON
// GET /api/v1/repositories/npm-proxy/health -> HTTP 503
{
  "status": "UNHEALTHY",
  "details": {
    "database": {
      "status": "OK"
    },
    "storage": {
      "status": "OK"
    },
    "proxy_remote_connection": {
      "status": "FAILED",
      "error": "Connection timed out after 2000ms"
    }
  }
}