# Historia 4.11: Policy Conflict Detection

## Estado
- **Borrador (Draft)**

## Historia
**Como** administrador de políticas,
**necesito** que el sistema detecte automáticamente conflictos entre las políticas,
**para que** pueda evitar comportamientos de autorización inesperados o indeseados.

## Criterios de Aceptación
1.  Se ha creado un servicio `PolicyConflictDetector` que puede analizar un conjunto de políticas de Cedar.
2.  El servicio puede detectar conflictos de dependencia circular (p. ej., la política A depende de la B, y la B de la A).
3.  El servicio puede detectar políticas contradictorias (p. ej., una política `permit` y una `forbid` que se aplican exactamente a la misma tupla de principal, acción y recurso).
4.  Existe un endpoint de API (p. ej., `POST /api/v1/policies/analyze-conflicts`) que ejecuta el análisis sobre todas las políticas activas y devuelve un informe.
5.  El informe de resultados lista todos los conflictos encontrados, incluyendo los IDs de las políticas implicadas y la naturaleza del conflicto.
6.  Se publica un evento `PolicyConflictDetected` cuando el análisis encuentra uno o más conflictos.

## Tareas / Subtareas
- [ ] **Tarea 1: Implementar el Análisis de Grafos** (AC: #1, #2)
    - [ ] Crear una estructura de datos para representar las políticas y sus dependencias como un grafo dirigido.
    - [ ] Implementar un algoritmo de detección de ciclos en el grafo (p. ej., usando DFS).
- [ ] **Tarea 2: Implementar la Detección de Contradicciones** (AC: #3)
    - [ ] Implementar una lógica que compare pares de políticas para encontrar reglas directamente contradictorias (p. ej., `permit` vs `forbid` idénticos).
- [ ] **Tarea 3: Crear el Servicio de Detección**
    - [ ] Encapsular la lógica de grafos y contradicciones en el servicio `PolicyConflictDetector`.
    - [ ] El servicio debe obtener todas las políticas activas del `PolicyRepository`.
- [ ] **Tarea 4: Implementar el Endpoint de la API** (AC: #4, #5)
    - [ ] Añadir y implementar el endpoint `POST /api/v1/policies/analyze-conflicts`.
    - [ ] El handler debe invocar al servicio y formatear los resultados en un informe claro.
- [ ] **Tarea 5: Publicar Evento de Dominio** (AC: #6)
    - [ ] Si el informe contiene conflictos, publicar el evento `PolicyConflictDetected` con un resumen de los hallazgos.
- [ ] **Tarea 6: Añadir Pruebas**
    - [ ] Escribir pruebas unitarias con conjuntos de políticas que contengan ciclos y contradicciones para verificar que los algoritmos de detección funcionan.
    - [ ] Escribir una prueba de integración para el endpoint de la API.

## Notas para el Desarrollador
Un conjunto grande de políticas puede volverse difícil de razonar. Este servicio proactivo ayuda a mantener la integridad del sistema de autorización.

### Patrón de Implementación
* La implementación debe basarse en el patrón **"Policy Graph Analysis with Cycle Detection"** de la investigación técnica. El enfoque es tratar las políticas como nodos en un grafo y sus dependencias como aristas.
    ```rust
    // Pseudocódigo de referencia para la detección de conflictos
    // Fuente: Investigación Técnica de la Épica E4
    fn detect_policy_conflicts(policies: &[Policy]) -> Vec<PolicyConflict> {
        let mut graph = PolicyGraph::new();
        
        // 1. Construir el grafo de dependencias de políticas
        for policy in policies {
            graph.add_node(policy.id(), policy);
            for dependency in policy.dependencies() {
                graph.add_edge(policy.id(), dependency);
            }
        }
        
        // 2. Detectar ciclos
        let cycles = graph.detect_cycles();
        
        // 3. Detectar contradicciones
        let contradictions = graph.find_contradictions();
        
        cycles.into_iter().chain(contradictions).collect()
    }
    ```

### Alcance del Análisis
* El análisis puede ser computacionalmente intensivo. Debe ejecutarse como una tarea bajo demanda (a través de la API) o como un proceso en segundo plano programado, en lugar de en tiempo real con cada cambio de política.

