# Story 5.16: Repository Webhooks

## Status
- Draft

## Story
**Como** un Ingeniero de Automatización,
**quiero** configurar un webhook en un repositorio para que notifique a un sistema externo (como Jenkins o Slack) cada vez que se sube un nuevo artefacto,
**para** poder disparar automáticamente pipelines de CI/CD, análisis de seguridad adicionales o simplemente informar al equipo.

## Acceptance Criteria
1.  Un usuario puede crear, listar y eliminar webhooks para un repositorio a través de la API.
2.  Al crear un webhook, se debe especificar la URL de destino, un secreto para la firma y los eventos que lo disparan (ej: `artifact.uploaded`).
3.  Cuando ocurre un evento suscrito en el repositorio (ej: se sube un artefacto), el sistema debe enviar una petición `POST` a la URL del webhook.
4.  La petición debe contener un payload JSON con detalles del evento (repositorio, artefacto, principal que realizó la acción, etc.).
5.  La petición debe incluir una cabecera `X-Hub-Signature-256` con la firma HMAC-SHA256 del payload, calculada usando el secreto configurado.
6.  Si el endpoint del webhook falla (no devuelve un código 2xx o hay un timeout), el sistema debe reintentar la entrega varias veces con un retardo creciente (exponential backoff).
7.  Se debe registrar el historial de entregas de cada webhook, incluyendo el éxito o el fracaso y el código de respuesta.

## Tasks / Subtasks
- [ ] Tarea 1: Diseñar los modelos de datos para los webhooks y sus logs. (AC: 1, 7)
    - [ ] Subtarea 1.1: Crear una colección `webhooks` en MongoDB. La struct `Webhook` en Rust debe contener `repository_id`, `target_url`, `secret_key`, `events: Vec<String>`, `is_active: bool`.
    - [ ] Subtarea 1.2: Crear una colección `webhook_delivery_logs` para registrar cada intento de entrega.
- [ ] Tarea 2: Implementar la API de gestión de webhooks. (AC: 1)
    - [ ] Subtarea 2.1: Crear los endpoints CRUD en `/api/v1/repositories/{repo_name}/webhooks`. El `secret_key` debe ser de solo escritura y nunca devolverse en las peticiones GET.
- [ ] Tarea 3: Desarrollar el servicio que consume eventos internos y encola las entregas. (AC: 2, 3)
    - [ ] Subtarea 3.1: Crear un `WebhookService` que consuma los eventos de la cola principal de RabbitMQ (ej: `artifact.uploaded`).
    - [ ] Subtarea 3.2: Al recibir un evento, el servicio consultará la colección `webhooks` para encontrar las suscripciones que coincidan.
    - [ ] Subtarea 3.3: Para cada coincidencia, el servicio construirá el payload JSON y encolará un `WebhookDeliveryJob` en una nueva cola de RabbitMQ dedicada a las entregas.
- [ ] Tarea 4: Implementar el "worker" de entrega de webhooks. (AC: 3, 4, 5, 6, 7)
    - [ ] Subtarea 4.1: Crear un nuevo servicio consumidor (`delivery-worker`) que lea los `WebhookDeliveryJob` de la cola de entregas.
    - [ ] Subtarea 4.2: Implementar la lógica para generar la firma HMAC-SHA256 del payload y añadirla a la cabecera.
    - [ ] Subtarea 4.3: Implementar el cliente HTTP que realizará la petición `POST`.
    - [ ] Subtarea 4.4: Implementar la lógica de reintentos con `exponential backoff` para manejar fallos.
    - [ ] Subtarea 4.5: Tras cada intento (exitoso o fallido), registrar el resultado en la colección `webhook_delivery_logs`.
- [ ] Tarea 5: Pruebas.
    - [ ] Subtarea 5.1: Usar un servidor mock (ej: `wiremock-rs`) como endpoint de destino para un webhook.
    - [ ] Subtarea 5.2: Realizar una subida de artefacto y verificar que el servidor mock recibe una petición POST con el payload y la firma correctos.
    - [ ] Subtarea 5.3: Configurar el mock para que devuelva errores 500 y verificar que el worker realiza los reintentos correctamente.

## Dev Notes

### Guía de Implementación y Contexto Arquitectónico

**Decisión Arquitectónica Clave: Sistema de Doble Cola para Resiliencia**
Para evitar que un webhook lento o fallido afecte al resto del sistema, es crucial desacoplar el procesamiento de eventos de la entrega de los mismos.

```text
 Evento         Servicio de Webhooks        Cola de Entregas        Worker de Entregas        Sistema
 (RabbitMQ)  -->  (Consume eventos,       -->   (RabbitMQ,          -->  (Consume jobs,      -->    Externo
               encola jobs de entrega)       contiene jobs)         realiza POSTs,
                                                                    maneja reintentos)