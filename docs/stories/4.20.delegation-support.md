### **Historia 4.20: Delegation Support**

#### **Proceso de Creación**
* **Identificada siguiente historia:** 4.20 - Delegation Support.
* **Recopilación:** Esta es una historia avanzada sobre patrones de autorización. Introduce la capacidad de que un principal actúe en nombre de otro. Esto requiere modelar la relación de delegación y hacerla disponible para el motor de políticas de Cedar.
* **Checklist:** Ejecutando la `story-draft-checklist`... **Resultado:** ✅ **LISTA**.

#### **Archivo: `docs/stories/4.20.Delegation-Support.md`**

# Historia 4.20: Delegation Support

## Estado
- **Borrador (Draft)**

## Historia
**Como** un usuario con privilegios (p. ej., un manager),
**quiero** delegar temporalmente algunos de mis permisos a otro usuario,
**para que** pueda actuar en mi nombre mientras estoy ausente.

## Criterios de Aceptación
1.  Se ha definido un modelo de datos `Delegation` que representa una concesión de delegación de un principal (el delegante) a otro (el delegado), posiblemente para un recurso o ámbito específico y con una fecha de expiración.
2.  Existen endpoints de API para crear y revocar estas delegaciones.
3.  El mapeo de `User` a `CedarEntity` se ha extendido para incluir un atributo que represente las delegaciones activas para ese usuario (p. ej., `delegated_by`).
4.  Es posible escribir una política de Cedar que utilice esta relación de delegación para tomar una decisión de acceso.
5.  [cite_start]Se publica un evento `AccessDelegated` cuando se crea una delegación. [cite: 25]
6.  [cite_start]Se publica un evento `DelegationRevoked` cuando se revoca una delegación. [cite: 25]

## Tareas / Subtareas
- [ ] **Tarea 1: Definir el Modelo y Repositorio** (AC: #1)
    - [ ] Definir la estructura `Delegation` (delegante, delegado, recurso/ámbito opcional, fecha de expiración).
    - [ ] Crear un `DelegationRepository` con métodos para crear, revocar y consultar delegaciones activas. Implementar una versión en memoria.
- [ ] **Tarea 2: Implementar los Endpoints de la API** (AC: #2)
    - [ ] Añadir endpoints en la especificación OpenAPI para `POST /api/v1/delegations` (crear) y `DELETE /api/v1/delegations/{id}` (revocar).
    - [ ] Implementar los handlers correspondientes.
- [ ] **Tarea 3: Integrar la Delegación en el Contexto de Cedar** (AC: #3)
    - [ ] Modificar el `AuthorizationService` o la capa que construye los `principal` de Cedar.
    - [ ] Antes de una evaluación, consultar las delegaciones activas para el solicitante y añadir esta información a los atributos de la entidad `principal` que se pasa a Cedar.
- [ ] **Tarea 4: Publicar Eventos de Dominio** (AC: #5, #6)
    - [ ] Integrar la publicación de los eventos `AccessDelegated` y `DelegationRevoked` en los handlers de la API.
- [ ] **Tarea 5: Añadir Pruebas**
    - [ ] Escribir una prueba de integración que:
        1.  Cree una política que permita una acción solo a un delegado.
        2.  Cree una delegación del `UsuarioA` al `UsuarioB` vía API.
        3.  Verifique que el `UsuarioB` ahora puede realizar la acción.
        4.  Revoque la delegación.
        5.  Verifique que el `UsuarioB` ya no puede realizar la acción.

## Notas para el Desarrollador
La delegación es un patrón de autorización complejo. La clave es modelar la delegación como un atributo del `principal` que solicita el acceso.

### Ejemplo de Política de Delegación
* Con la información de delegación en el `principal`, se pueden escribir políticas como esta:
    ```cedar
    // Permitir a un delegado aprobar solicitudes si el dueño del recurso se lo ha delegado.
    permit(principal, action == Action::"approveRequest", resource)
    when {
        // resource.owner es una entidad, la comparamos con el atributo del principal
        resource.owner in principal.delegated_by
    };
    ```
* Para que esto funcione, cuando el `UsuarioB` (delegado) hace una solicitud, su entidad Cedar debe ser enriquecida con `delegated_by = { User::"UsuarioA" }`.