# Historia 4.6: Group Management

## Estado
- **Borrador (Draft)**

## Historia
**Como** administrador del sistema,
**necesito** crear y gestionar grupos de usuarios, así como sus membresías,
**para que** pueda asignar políticas a múltiples usuarios a la vez en lugar de hacerlo individualmente.

## Criterios de Aceptación
1.  Se ha definido un modelo de datos para la entidad `Group`, que incluye `id`, `name`, y `description`.
2.  Existen endpoints de API para las operaciones CRUD sobre los grupos.
3.  Existe un endpoint de API para añadir un usuario a un grupo por sus respectivos IDs.
4.  Existe un endpoint de API para eliminar un usuario de un grupo.
5.  Cuando se añade un usuario a un grupo, el registro del usuario se actualiza para reflejar la nueva membresía, y se publica un evento `UserAddedToGroup`.
6.  Cuando se elimina un usuario de un grupo, se publica un evento `UserRemovedFromGroup`.
7.  Se publican los eventos `GroupCreated`, `GroupUpdated`, y `GroupDeleted` en sus operaciones CRUD correspondientes.
8.  El modelo `Group` implementa el trait `CedarEntity`, permitiendo que los grupos sean utilizados como `principal` en las políticas de Cedar.

## Tareas / Subtareas
- [ ] **Tarea 1: Definir el Modelo y Repositorio de Grupo** (AC: #1)
    - [ ] Definir la estructura `Group` en el código.
    - [ ] Crear un trait `GroupRepository` que defina las operaciones CRUD, además de `add_member` y `remove_member`.
    - [ ] Implementar una versión inicial en memoria, `InMemoryGroupRepository`.
- [ ] **Tarea 2: Definir Endpoints de la API**
    - [ ] Añadir los endpoints CRUD para `/api/v1/groups` a la especificación OpenAPI.
    - [ ] Añadir los endpoints de gestión de membresía, p. ej., `POST /api/v1/groups/{groupId}/members` y `DELETE /api/v1/groups/{groupId}/members/{userId}`.
- [ ] **Tarea 3: Implementar los Handlers de la API** (AC: #2, #3, #4)
    - [ ] Implementar los handlers para el CRUD de grupos.
    - [ ] Implementar los handlers para añadir y eliminar miembros de un grupo. Estos handlers necesitarán interactuar tanto con el `GroupRepository` como con el `UserRepository`.
- [ ] **Tarea 4: Publicar Eventos de Dominio** (AC: #5, #6, #7)
    - [ ] Integrar la publicación de todos los eventos de grupo (`GroupCreated`, etc.) y de membresía (`UserAddedToGroup`, etc.) en los handlers correspondientes.
- [ ] **Tarea 5: Implementar la Integración con Cedar** (AC: #8)
    - [ ] Implementar el trait `CedarEntity` para la estructura `Group`.
    - [ ] Añadir pruebas que verifiquen que una instancia de `Group` se convierte correctamente en una `cedar_policy::Entity`.
- [ ] **Tarea 6: Añadir Pruebas**
    - [ ] Escribir pruebas unitarias para el `GroupRepository`, especialmente para la lógica de membresía.
    - [ ] Escribir pruebas de integración para todos los endpoints nuevos, verificando que al añadir un miembro a un grupo, el `User` afectado refleja el cambio.

## Notas para el Desarrollador
Esta historia introduce el concepto de grupos, que son fundamentales en cualquier sistema de permisos. Un grupo es, en sí mismo, un `principal` en el modelo de Cedar.

### Gestión de Membresías
* La lógica más compleja de esta historia reside en la gestión de las membresías. Cuando se añade un usuario a un grupo, se deben actualizar dos entidades: el grupo (si mantiene una lista de miembros) y el usuario (para actualizar su campo `group_memberships`). La consistencia entre ambos es clave.
* El `UserRepository` de la historia `4.5` debe ser inyectado en los handlers de membresía de grupos para poder actualizar la entidad del usuario.

### Uso en Políticas de Cedar
* El objetivo final es poder escribir políticas simples y potentes como la siguiente:
    ```cedar
    // Permitir a cualquier miembro del grupo "developers" leer cualquier artefacto.
    permit(
      principal in Group::"developers",
      action == Action::"read",
      resource
    );
    ```
* Para que esto funcione, tanto `User` (con su atributo `memberOf`) como `Group` deben ser entidades `principal` válidas en el esquema de Cedar. El `CedarEntity` trait para `Group` es, por tanto, un requisito indispensable.

## Pruebas
* Las pruebas de integración son críticas aquí. Un buen escenario de prueba sería:
    1. Crear un usuario.
    2. Crear un grupo.
    3. Añadir el usuario al grupo vía API.
    4. Leer la entidad del usuario y verificar que la membresía al grupo está presente en sus atributos.
    5. Eliminar al usuario del grupo.
    6. Leer de nuevo la entidad del usuario y verificar que la membresía ha sido eliminada.

## Registro de Cambios
| Fecha | Versión | Descripción | Autor |
| :--- | :--- | :--- | :--- |
| 2025-09-10 | 1.0 | Borrador inicial | sm (Bob) |