### **Historia 4.24: Risk-Based Access Control**

#### **Proceso de Creación**
* **Identificada siguiente historia:** 4.24 - Risk-Based Access Control.
* **Recopilación:** Esta es una historia de seguridad muy avanzada (Prioridad P3). Introduce un control adaptativo basado en el riesgo de cada solicitud de acceso. La investigación técnica proporciona un algoritmo claro: calcular una puntuación de riesgo y pasarla como `contexto` al motor de Cedar para que las políticas puedan reaccionar a ella.
* **Checklist:** Ejecutando la `story-draft-checklist`... **Resultado:** ✅ **LISTA**.

#### **Archivo: `docs/stories/4.24.Risk-Based-Access-Control.md`**

# Historia 4.24: Risk-Based Access Control

## Estado
- **Borrador (Draft)**

## Historia
**Como** sistema de seguridad,
**quiero** evaluar el nivel de riesgo de cada solicitud de acceso y usarlo para tomar decisiones de autorización más inteligentes,
**para que** pueda aplicar controles más estrictos (p. ej., requerir MFA, denegar acceso) a las operaciones de alto riesgo.

## Criterios de Aceptación
1.  Se ha implementado un `RiskAssessmentEngine` que calcula una puntuación de riesgo para una solicitud de acceso dada.
2.  La puntuación de riesgo se calcula basándose en factores contextuales como: hora del día, geolocalización de la IP, si el dispositivo es conocido, frecuencia de la acción, etc.
3.  El `AuthorizationService` utiliza este motor para obtener una puntuación de riesgo antes de cada evaluación de política.
4.  La puntuación de riesgo y el nivel de riesgo resultante (p. ej., "bajo", "medio", "alto") se añaden al `context` de la evaluación de Cedar.
5.  Es posible escribir una política de Cedar que utilice los atributos de riesgo del contexto (p. ej., `when { context.risk_level == "alto" }`).
6.  Se publica un evento `RiskAssessmentPerformed` con la puntuación calculada.
7.  Se publica un evento `RiskBasedDecisionMade` que indica que una decisión fue influenciada por factores de riesgo.

## Tareas / Subtareas
- [ ] **Tarea 1: Implementar el Motor de Riesgo** (AC: #1, #2)
    - [ ] Crear el `RiskAssessmentEngine`.
    - [ ] Definir un conjunto inicial de reglas o factores de riesgo y asignarles un peso.
    - [ ] Implementar el método `assess_risk` que toma el contexto de una solicitud y devuelve una puntuación numérica.
- [ ] **Tarea 2: Integrar con el Flujo de Autorización** (AC: #3, #4)
    - [ ] Modificar el `AuthorizationService` para que llame al `RiskAssessmentEngine` antes de la evaluación de Cedar.
    - [ ] Enriquecer el `context` de Cedar con la puntuación y el nivel de riesgo.
- [ ] **Tarea 3: Implementar la Lógica de Contexto** (AC: #5)
    - [ ] Asegurarse de que los atributos de riesgo se añaden al `context` de forma que las políticas de Cedar puedan usarlos.
- [ ] **Tarea 4: Publicar Eventos de Dominio** (AC: #6, #7)
    - [ ] Integrar la publicación de los eventos de riesgo en el `AuthorizationService`.
- [ ] **Tarea 5: Añadir Pruebas**
    - [ ] Escribir pruebas unitarias para el motor de riesgo, probando diferentes combinaciones de factores de riesgo.
    - [ ] Escribir una prueba de integración que defina una política basada en riesgo y verifique que una solicitud de alto riesgo es denegada mientras que una de bajo riesgo es permitida.

## Notas para el Desarrollador
Esta es una capacidad de seguridad adaptativa muy potente. Permite al sistema ir más allá de las políticas estáticas.

### Patrón de Implementación
* La implementación debe seguir el patrón **"Dynamic Risk Scoring with Adaptive Policies"** de la investigación técnica. El motor de riesgo actúa como un pre-procesador que enriquece el contexto para el motor de políticas.
    ```rust
    // Pseudocódigo de referencia para el control de acceso basado en riesgo
    // Fuente: Investigación Técnica de la Épica E4
    struct RiskBasedAccessControl {
        risk_assessment_engine: Arc<dyn RiskAssessmentEngine>,
        policy_engine: Arc<dyn PolicyEngine>,
    }

    impl RiskBasedAccessControl {
        async fn evaluate_with_risk(&self, request: &AccessRequest) -> Result<AccessDecision> {
            // 1. Calcular la puntuación de riesgo
            let risk_score = self.risk_assessment_engine.assess_risk(request).await?;
            let risk_level = self.determine_risk_level(risk_score);
            
            // 2. Enriquecer el contexto para Cedar
            let mut context = request.context.clone();
            context.insert("risk_score".to_string(), risk_score.into());
            context.insert("risk_level".to_string(), risk_level.to_string().into());
            
            // 3. Evaluar la política con el contexto enriquecido
            self.policy_engine.evaluate(
                &request.policy,
                &request.principal,
                &request.resource,
                &context,
            ).await?
        }
    }
    ```