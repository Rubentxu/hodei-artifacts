# Story 5.9: Repository Mirroring

## Status
- Draft

## Story
**Como** un Arquitecto de Infraestructura,
**quiero** configurar un repositorio proxy como un "mirror" de un repositorio remoto crítico,
**para** asegurar la disponibilidad de las dependencias clave y reducir la latencia de descarga, incluso si el repositorio externo está inaccesible.

## Acceptance Criteria
1.  Se puede habilitar el modo "mirror" en un repositorio de tipo "proxy" a través de la API, especificando un intervalo de sincronización (ej: cada 24 horas).
2.  Una vez habilitado, un trabajo en segundo plano debe sincronizar automáticamente el contenido del repositorio remoto con el local según el intervalo definido.
3.  La sincronización debe ser incremental: solo debe descargar los artefactos que son nuevos o han sido actualizados en el repositorio remoto desde la última sincronización.
4.  Un administrador puede disparar una sincronización manualmente a través de un endpoint de la API.
5.  El inicio, fin y resultado de cada trabajo de sincronización (manual o automático) deben quedar registrados, incluyendo el número de artefactos sincronizados.
6.  Las peticiones de artefactos al repositorio configurado como mirror deben servirse desde la copia local sin contactar al repositorio remoto.

## Tasks / Subtasks
- [ ] Tarea 1: Extender el modelo de datos para la configuración de mirroring. (AC: 1)
    - [ ] Subtarea 1.1: Añadir una struct `MirrorConfig` a la configuración de los repositorios proxy.
    - [ ] Subtarea 1.2: La struct debe contener campos como `enabled: bool`, `sync_interval_minutes: u32`, y `last_sync_status: SyncStatus`.
- [ ] Tarea 2: Implementar la API de gestión de mirroring. (AC: 1, 4)
    - [ ] Subtarea 2.1: Crear un endpoint `PUT /api/v1/repositories/{repo_name}/mirror-config` para establecer la configuración de mirroring.
    - [ ] Subtarea 2.2: Crear un endpoint `POST /api/v1/repositories/{repo_name}/mirror-sync` para encolar un trabajo de sincronización manual.
- [ ] Tarea 3: Desarrollar el servicio de sincronización. (AC: 3, 5)
    - [ ] Subtarea 3.1: Crear un nuevo servicio `MirroringService`.
    - [ ] Subtarea 3.2: Implementar la lógica para obtener el índice de artefactos del repositorio remoto (ej: parsear `maven-metadata.xml`).
    - [ ] Subtarea 3.3: Implementar la lógica para comparar el índice remoto con el estado del repositorio local y generar una lista de "artefactos a descargar".
    - [ ] Subtarea 3.4: Implementar un bucle de descarga que procese la lista de artefactos pendientes y los guarde en el almacenamiento local.
    - [ ] Subtarea 3.5: Actualizar el estado (`last_sync_status`) del repositorio al finalizar la sincronización.
- [ ] Tarea 4: Integrar el servicio con el planificador de tareas. (AC: 2)
    - [ ] Subtarea 4.1: Crear un nuevo job recurrente que se ejecute (ej: cada 5 minutos) y consulte los repositorios que tengan el mirroring habilitado.
    - [ ] Subtarea 4.2: El job debe verificar si ha pasado el tiempo `sync_interval_minutes` desde la última sincronización de cada repositorio y, si es así, encolar un trabajo de sincronización para él.
- [ ] Tarea 5: Adaptar la lógica de descarga. (AC: 6)
    - [ ] Subtarea 5.1: Modificar el `ArtifactService` para que, si un repositorio es un mirror (`mirror.enabled == true`), sirva los artefactos directamente desde la copia local sin intentar contactar al `remote_url`.
- [ ] Tarea 6: Pruebas.
    - [ ] Subtarea 6.1: Probar que la sincronización inicial descarga todo el contenido.
    - [ ] Subtarea 6.2: Probar que una segunda sincronización, sin cambios en el remoto, no descarga ningún artefacto.
    - [ ] Subtarea 6.3: Añadir un artefacto al remoto (mock) y probar que la siguiente sincronización solo descarga ese nuevo artefacto.

## Dev Notes

### Relevant Source Tree info
- **ASUNCIÓN**: La lógica de sincronización debería vivir en un nuevo módulo `crates/artifactory/src/mirroring/`.

### API Specifications
- **ASUNCIÓN**:
    - `PUT /api/v1/repositories/{repo_name}/mirror-config` Body: `{ "enabled": true, "sync_interval_minutes": 1440 }`.
    - `POST /api/v1/repositories/{repo_name}/mirror-sync`: Sin body. Devuelve `202 Accepted` con el ID del job de sincronización.

### Architecture Considerations
- **Decisión Arquitectónica Clave**: **Proxy vs. Mirror**. Es fundamental distinguir sus comportamientos. Un **Proxy** es reactivo y cachea bajo demanda. Un **Mirror** es proactivo y sincroniza en segundo plano. La implementación debe reflejar esto: un repositorio no puede ser ambos a la vez. Cuando el modo mirror está activo, la lógica del proxy (contactar al remoto si el artefacto no está en caché) se desactiva.
- **Sincronización Inteligente**: La eficiencia del mirror depende de su capacidad para determinar qué ha cambiado sin descargar todo. Esto requiere implementar "parsers" de índices específicos para cada formato de paquete. Para Maven, esto implica descargar y analizar los `maven-metadata.xml`. Para npm, sería consultar el JSON del paquete. La arquitectura debe permitir añadir nuevos parsers de forma modular.

### Testing
- **ASUNCIÓN**: Las pruebas de integración requerirán un servidor HTTP mock que actúe como el "repositorio remoto". Esto permitirá simular cambios en el remoto (añadir/eliminar artefactos) y verificar que el `MirroringService` reacciona correctamente.