
### **Historia 4.10: Policy Versioning**

#### **Proceso de Creación**
* **Identificada siguiente historia:** 4.10 - Policy Versioning.
* **Recopilación:** Esta historia modifica el comportamiento del CRUD de políticas de la historia `4.2`. En lugar de que las actualizaciones sean destructivas, se introduce un sistema de versionado inmutable, crucial para la auditoría y la capacidad de rollback.
* **Checklist:** Ejecutando la `story-draft-checklist`... **Resultado:** ✅ **LISTA**.

#### **Archivo: `docs/stories/4.10.Policy-Versioning.md`**

# Historia 4.10: Policy Versioning

## Estado
- **Borrador (Draft)**

## Historia
**Como** administrador de políticas,
**necesito** que el sistema versione las políticas de forma inmutable cada vez que se modifican,
**para que** pueda auditar los cambios a lo largo del tiempo y revertir a una versión anterior si es necesario.

## Criterios de Aceptación
1.  El modelo de datos de `Policy` se ha extendido para incluir un `version` (entero o similar), un `policy_id` (que agrupa las versiones) y un booleano `is_active`.
2.  La operación de "actualización" (`PUT /api/v1/policies/{id}`) ahora es no destructiva: desactiva la versión activa actual (`is_active = false`) y crea una nueva versión activa con los cambios.
3.  La operación de "lectura" (`GET /api/v1/policies/{id}`) por defecto devuelve la versión activa de la política.
4.  Se ha creado un nuevo endpoint de API (`GET /api/v1/policies/{id}/versions`) que devuelve todas las versiones de una política.
5.  Se ha creado un nuevo endpoint de API (`POST /api/v1/policies/{id}/revert`) que permite revertir a una versión anterior, lo que crea una nueva versión basada en una antigua.
6.  Se publica un evento `PolicyVersionCreated` cada vez que se crea una nueva versión de una política.
7.  Se publica un evento `PolicyVersionReverted` al revertir a una versión anterior.

## Tareas / Subtareas
- [ ] **Tarea 1: Modificar el Modelo de Datos de Policy** (AC: #1)
    - [ ] Añadir los campos `version`, `policy_id` y `is_active` a la estructura `Policy`.
- [ ] **Tarea 2: Actualizar el Repositorio de Políticas** (AC: #2, #3, #4, #5)
    - [ ] Modificar el trait `PolicyRepository` y su implementación.
    - [ ] El método `update` ahora debe implementar la lógica de versionado (desactivar la antigua, crear la nueva).
    - [ ] Añadir nuevos métodos como `list_versions` y `revert_to_version`.
- [ ] **Tarea 3: Actualizar los Endpoints de la API** (AC: #2, #3, #4, #5)
    - [ ] Modificar el handler `PUT /api/v1/policies/{id}` para que utilice la nueva lógica del repositorio.
    - [ ] Implementar los nuevos endpoints para listar versiones y revertir.
- [ ] **Tarea 4: Publicar Eventos de Versionado** (AC: #6, #7)
    - [ ] Integrar la publicación de los eventos `PolicyVersionCreated` y `PolicyVersionReverted` en los handlers correspondientes.
- [ ] **Tarea 5: Añadir Pruebas**
    - [ ] Escribir pruebas unitarias para la nueva lógica del repositorio, especialmente para el versionado y la reversión.
    - [ ] Escribir pruebas de integración para los endpoints de la API, verificando que una actualización crea una nueva versión y que la reversión funciona correctamente.

## Notas para el Desarrollar
El objetivo de esta historia es eliminar las actualizaciones destructivas de las políticas. Cada cambio debe resultar en una nueva versión, creando un historial inmutable que es esencial para la seguridad y la auditoría.

### Lógica de Versionado
* Cuando un usuario "actualiza" una política, lo que realmente está haciendo es crear una nueva versión de esa política. El `policy_id` sirve para agrupar todas estas versiones.
* Solo puede haber una versión `is_active` por `policy_id` en un momento dado.
* La "reversión" no es más que crear una nueva versión cuyo contenido se copia de una versión antigua.