### **Historia 4.16: Service Account Management**

#### **Proceso de Creación**
* **Identificada siguiente historia:** 4.16 - Service Account Management.
* **Recopilación:** Esta historia introduce un nuevo tipo de `Principal` no humano. Las cuentas de servicio son esenciales para las automatizaciones (CI/CD, etc.). Se autenticarán usando las claves de API de la historia anterior, pero primero deben existir como una entidad a la que se le puedan asignar permisos.
* **Checklist:** Ejecutando la `story-draft-checklist`... **Resultado:** ✅ **LISTA**.

#### **Archivo: `docs/stories/4.16.Service-Account-Management.md`**

# Historia 4.16: Service Account Management

## Estado
- **Borrador (Draft)**

## Historia
**Como** administrador del sistema,
**quiero** crear y gestionar cuentas de servicio,
**para que** pueda otorgar permisos a sistemas automatizados y aplicaciones de una manera segura y aislada de las cuentas de usuario.

## Criterios de Aceptación
1.  Se ha definido un modelo de datos para `ServiceAccount`, que incluye `id`, `name`, y `status` (activo/inactivo).
2.  Las cuentas de servicio son un tipo de `principal` y pueden ser utilizadas en las políticas de Cedar (p. ej., `principal == ServiceAccount::"ci-bot"`).
3.  El modelo `ServiceAccount` implementa el trait `CedarEntity`.
4.  Existen endpoints de API para las operaciones CRUD sobre las cuentas de servicio.
5.  Una cuenta de servicio puede tener claves de API asociadas (creadas a través del flujo de la historia 4.15).
6.  Se publica un evento `ServiceAccountCreated` cuando se crea una nueva cuenta de servicio.

## Tareas / Subtareas
- [ ] **Tarea 1: Definir el Modelo y Repositorio** (AC: #1)
    - [ ] Definir la estructura `ServiceAccount`.
    - [ ] Crear un `ServiceAccountRepository` con operaciones CRUD y una implementación en memoria.
- [ ] **Tarea 2: Implementar la Integración con Cedar** (AC: #2, #3)
    - [ ] Implementar el trait `CedarEntity` para la estructura `ServiceAccount`. El tipo de entidad en Cedar debe ser `ServiceAccount`.
- [ ] **Tarea 3: Implementar los Endpoints de la API** (AC: #4)
    - [ ] Añadir endpoints CRUD para `/api/v1/service-accounts` a la especificación OpenAPI.
    - [ ] Implementar los handlers correspondientes.
- [ ] **Tarea 4: Integrar con la Gestión de Claves de API** (AC: #5)
    - [ ] Modificar el flujo de creación de claves de API (`POST /api/v1/keys`) para permitir que una clave sea propiedad de una `ServiceAccount`.
- [ ] **Tarea 5: Publicar Evento de Dominio** (AC: #6)
    - [ ] Integrar la publicación del evento `ServiceAccountCreated` en el handler de creación.
- [ ] **Tarea 6: Añadir Pruebas**
    - [ ] Escribir pruebas unitarias para el `ServiceAccountRepository`.
    - [ ] Escribir pruebas de integración para los endpoints de la API.
    - [ ] Escribir una prueba que cree una cuenta de servicio, le asigne una clave de API y use esa clave para autenticarse.

## Notas para el Desarrollador
Esta historia crea un `principal` de primera clase para sistemas no humanos. Es conceptualmente similar a la gestión de usuarios, pero para máquinas.

### Modelo de `Principal` Unificado
* Tanto `User` como `ServiceAccount` son tipos de `principal`. A nivel de la API de autorización, deberían ser tratables de forma similar. Las políticas de Cedar pueden diferenciar fácilmente entre ellos por su tipo.
    ```cedar
    // Política que solo se aplica a usuarios
    permit(principal, action, resource) when { principal.entityType == "User" };

    // Política que solo se aplica a cuentas de servicio
    permit(principal, action, resource) when { principal.entityType == "ServiceAccount" };
    ```
* La implementación del trait `CedarEntity` para `ServiceAccount` es clave para que esto funcione.