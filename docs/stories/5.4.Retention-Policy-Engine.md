# Story 5.4: Retention Policy Engine

## Status
- Draft

## Story
**Como** un Administrador del Sistema,
**quiero** definir políticas de retención automáticas para un repositorio,
**para** poder gestionar el uso del almacenamiento y asegurar que solo los artefactos relevantes se conserven a lo largo del tiempo.

## Acceptance Criteria
1.  Un administrador puede crear una política de retención para un repositorio a través de la API.
2.  La política debe soportar una regla basada en la antigüedad: "eliminar artefactos más antiguos de X días".
3.  La política debe soportar una regla basada en el número de versiones: "conservar solo las últimas Y versiones de un artefacto".
4.  Las políticas de retención se ejecutan automáticamente en segundo plano según una programación definida (ej: diariamente).
5.  La ejecución de una política debe quedar registrada en un log, indicando qué artefactos fueron eliminados.
6.  Los artefactos eliminados por una política de retención se purgan de forma permanente del almacenamiento.

## Tasks / Subtasks
- [ ] Tarea 1: Modelar y almacenar las políticas de retención. (AC: 1, 2, 3)
    - [ ] Subtarea 1.1: Definir una enum `RetentionRule` en Rust con variantes como `MaxAge { days: u32 }` y `MaxCount { count: u32 }`.
    - [ ] Subtarea 1.2: Extender el modelo de datos del repositorio en MongoDB para almacenar una lista de estas políticas.
- [ ] Tarea 2: Implementar la API para la gestión de políticas. (AC: 1)
    - [ ] Subtarea 2.1: Crear endpoints CRUD en la API (`/api/v1/repositories/{repo_name}/retention-policies`) para añadir, ver y eliminar políticas de un repositorio.
- [ ] Tarea 3: Desarrollar el motor de ejecución de políticas. (AC: 2, 3, 6)
    - [ ] Subtarea 3.1: Crear un servicio `RetentionService` que pueda procesar las políticas de un repositorio.
    - [ ] Subtarea 3.2: Implementar la lógica para consultar los metadatos de los artefactos y filtrar los candidatos a ser eliminados según las reglas (antigüedad, conteo).
    - [ ] Subtarea 3.3: Implementar la lógica de eliminación segura de los artefactos del sistema de almacenamiento (S3 o similar).
- [ ] Tarea 4: Integrar un planificador de tareas (job scheduler). (AC: 4, 5)
    - [ ] Subtarea 4.1: Añadir una librería de scheduling como `tokio-cron-scheduler` al proyecto.
    - [ ] Subtarea 4.2: Crear un job recurrente (ej: cada noche a las 02:00) que consulte todos los repositorios con políticas activas y dispare el `RetentionService` para cada uno.
    - [ ] Subtarea 4.3: Implementar un sistema de logging para registrar el inicio, fin y resultados de cada ejecución del job.
- [ ] Tarea 5: Añadir pruebas exhaustivas.
    - [ ] Subtarea 5.1: Pruebas unitarias para la lógica de filtrado de artefactos.
    - [ ] Subtarea 5.2: Pruebas de integración para verificar que el job se ejecuta y elimina los artefactos correctos sin afectar a los que deben conservarse.

## Dev Notes

### Relevant Source Tree info
- **ASUNCIÓN**: El motor de retención podría vivir en su propio módulo, `crates/artifactory/src/retention/`. La configuración del job scheduler se realizaría en el punto de entrada principal de la aplicación.

### API Specifications
- **ASUNCIÓN**:
    - `POST /api/v1/repositories/{repo_name}/retention-policies`: Crea una nueva política. Body: `{ "rule_type": "MaxAge", "params": { "days": 30 } }`.
    - `GET /api/v1/repositories/{repo_name}/retention-policies`: Lista las políticas activas.
    - `DELETE /api/v1/repositories/{repo_name}/retention-policies/{policy_id}`: Elimina una política.

### Architecture Considerations
- **ASUNCIÓN**: La ejecución de las políticas debe ser una tarea asíncrona en segundo plano para no bloquear el servidor. El proceso debe ser robusto y manejar posibles fallos (ej: un artefacto no se puede eliminar) sin detener la ejecución completa. Debería tener reintentos y logging detallado.

### Testing
- **ASUNCIÓN**: Las pruebas de esta funcionalidad son críticas. Se deben crear escenarios de prueba con un conjunto de artefactos con diferentes fechas de creación y versiones para verificar que las reglas `MaxAge` y `MaxCount` funcionan como se espera en todos los casos límite.