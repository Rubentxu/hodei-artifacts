# Story 5.5: Storage Quota Management

## Status
- Draft

## Story
**Como** un Administrador del Sistema,
**quiero** establecer y gestionar cuotas de almacenamiento para cada repositorio,
**para** prevenir el uso descontrolado del espacio en disco y controlar los costos de infraestructura.

## Acceptance Criteria
1.  Un administrador puede definir una cuota máxima de almacenamiento (en bytes) para un repositorio a través de la API.
2.  El sistema debe mantener un registro del espacio de almacenamiento actualmente utilizado por cada repositorio.
3.  Si una operación de subida (upload) de un artefacto hiciera que el repositorio excediera su cuota, la operación debe ser rechazada con un error 413 (Payload Too Large) antes de escribir el archivo.
4.  Cuando un artefacto se sube con éxito, el tamaño del repositorio se actualiza para reflejar el nuevo total.
5.  Cuando un artefacto se elimina (manual o por retención), el tamaño del repositorio se actualiza para reflejar el nuevo total.
6.  Es posible consultar el estado actual de la cuota de un repositorio (límite, usado, disponible) a través de la API.

## Tasks / Subtasks
- [ ] Tarea 1: Extender el modelo de datos del repositorio. (AC: 1, 2)
    - [ ] Subtarea 1.1: Añadir los campos `quota_bytes: Option<u64>` y `current_size_bytes: u64` al modelo de `Repository` en MongoDB y en las structs de Rust.
- [ ] Tarea 2: Implementar la API de gestión de cuotas. (AC: 1, 6)
    - [ ] Subtarea 2.1: Crear un endpoint `PUT /api/v1/repositories/{repo_name}/quota` para establecer el `quota_bytes`.
    - [ ] Subtarea 2.2: Crear un endpoint `GET /api/v1/repositories/{repo_name}/quota` para leer el estado de la cuota.
- [ ] Tarea 3: Integrar la lógica de comprobación de cuota en el servicio de subida de artefactos. (AC: 3, 4)
    - [ ] Subtarea 3.1: En el `ArtifactService`, antes de procesar una subida, obtener el tamaño del artefacto entrante y la cuota del repositorio.
    - [ ] Subtarea 3.2: Implementar la lógica de validación: si `current_size + artifact_size > quota`, rechazar la petición.
    - [ ] Subtarea 3.3: Si la validación es exitosa, después de escribir el artefacto, actualizar el campo `current_size_bytes` del repositorio usando una operación atómica (`$inc` en MongoDB).
- [ ] Tarea 4: Integrar la actualización de tamaño en el proceso de eliminación. (AC: 5)
    - [ ] Subtarea 4.1: En el `ArtifactService` y en el `RetentionService`, después de eliminar un artefacto, decrementar el `current_size_bytes` del repositorio de forma atómica.
- [ ] Tarea 5: Añadir pruebas para la funcionalidad de cuotas.
    - [ ] Subtarea 5.1: Pruebas de integración para los endpoints de la API de cuotas.
    - [ ] Subtarea 5.2: Probar el caso límite: subir un artefacto que llena el repositorio justo hasta la cuota.
    - [ ] Subtarea 5.3: Probar el caso de fallo: intentar subir un artefacto que excede la cuota y verificar que la operación es rechazada correctamente.

## Dev Notes

### Relevant Source Tree info
- **ASUNCIÓN**: La lógica de gestión de cuotas debería residir en `crates/artifactory/src/repositories/quota.rs` y ser invocada desde el servicio principal de artefactos.

### API Specifications
- **ASUNCIÓN**:
    - `PUT /api/v1/repositories/{repo_name}/quota` Body: `{ "quota_bytes": 10737418240 }` (para 10 GiB).
    - `GET /api/v1/repositories/{repo_name}/quota` Response: `{ "quota_bytes": 10737418240, "used_bytes": 512000, "available_bytes": 10736906240 }`.

### Architecture Considerations
- **ASUNCIÓN**: Es crucial que las actualizaciones del tamaño del repositorio (`current_size_bytes`) se realicen con operaciones atómicas para evitar condiciones de carrera (race conditions) si múltiples subidas o borrados ocurren simultáneamente. El operador `$inc` de MongoDB es ideal para esto. El cálculo del tamaño total del repositorio "al vuelo" mediante la suma de todos sus artefactos no es una opción viable, ya que sería demasiado lento para una comprobación previa a la subida.

### Testing
- **ASUNCIÓN**: Es importante probar que si una subida falla por cualquier motivo *después* de la comprobación de cuota, el tamaño del repositorio no se incremente incorrectamente. La actualización del tamaño debe estar ligada al éxito de la escritura del artefacto en el almacenamiento.