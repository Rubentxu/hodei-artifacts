# Story 5.18: Repository Template System

## Status
- Draft

## Story
**Como** un Administrador de la Organización,
**quiero** crear y gestionar plantillas de configuración para repositorios,
**para** poder estandarizar la configuración de los repositorios en toda la organización (ej: políticas de seguridad, configuración de proxy) y acelerar la creación de nuevos repositorios para los equipos de desarrollo.

## Acceptance Criteria
1.  Un administrador puede crear, leer, actualizar y eliminar plantillas de configuración a través de una API de sistema.
2.  Una plantilla debe contener un nombre, una descripción y un objeto de configuración completo para un tipo de repositorio específico.
3.  Al crear un nuevo repositorio, se puede especificar opcionalmente el nombre de una plantilla a utilizar.
4.  Si se usa una plantilla, el nuevo repositorio se crea con la configuración heredada de esa plantilla.
5.  Si al crear un repositorio se especifica una plantilla y también valores de configuración personalizados, los valores personalizados deben sobreescribir a los de la plantilla.
6.  Si se especifica un nombre de plantilla que no existe durante la creación, la petición debe fallar con un error claro.

## Tasks / Subtasks
- [ ] Tarea 1: Diseñar y crear el almacenamiento para las plantillas. (AC: 1, 2)
    - [ ] Subtarea 1.1: Crear una nueva colección `repository_templates` en MongoDB.
    - [ ] Subtarea 1.2: Definir una struct `RepositoryTemplate` en Rust que contenga `name: String`, `description: String` y `config: RepositoryConfig`.
- [ ] Tarea 2: Implementar la API de gestión de plantillas (CRUD). (AC: 1)
    - [ ] Subtarea 2.1: Crear un nuevo servicio `TemplateService` para manejar la lógica de negocio de las plantillas.
    - [ ] Subtarea 2.2: Implementar los endpoints CRUD en `/api/v1/system/repository-templates`.
- [ ] Tarea 3: Modificar el servicio de creación de repositorios para aplicar las plantillas. (AC: 3, 4, 5, 6)
    - [ ] Subtarea 3.1: Actualizar el endpoint `POST /api/v1/repositories` para que acepte un campo opcional `template_name: String` en el cuerpo de la petición.
    - [ ] Subtarea 3.2: En el `RepositoryService`, si se proporciona `template_name`, primero cargar la plantilla desde la base de datos. Si no existe, devolver un error.
    - [ ] Subtarea 3.3: Implementar la lógica de "fusión": tomar la configuración de la plantilla como base y sobreescribir los campos con los valores proporcionados en la petición de creación.
    - [ ] Subtarea 3.4: Utilizar esta configuración fusionada para crear el nuevo repositorio.
- [ ] Tarea 4: Pruebas.
    - [ ] Subtarea 4.1: Probar la API de CRUD de plantillas.
    - [ ] Subtarea 4.2: Probar la creación de un repositorio usando una plantilla y verificar que la configuración es correcta.
    - [ ] Subtarea 4.3: Probar la creación de un repositorio usando una plantilla pero sobreescribiendo uno de sus valores, y verificar que el valor sobreescrito es el que prevalece.
    - [ ] Subtarea 4.4: Probar que la creación falla si se pasa un `template_name` inválido.

## Dev Notes

### Guía de Implementación y Contexto Arquitectónico

**Decisión Arquitectónica Clave: Aplicación solo en el Momento de la Creación**
Es importante aclarar que las plantillas actúan como un "molde" inicial. Una vez que el repositorio es creado, no mantiene ninguna vinculación con la plantilla. Esto significa que si la plantilla se actualiza más tarde, los repositorios que se crearon a partir de ella **no se verán afectados**. Este comportamiento es intencional para evitar cambios inesperados y en cascada en la infraestructura existente.

**Lógica de Fusión de Configuraciones (Merge Logic):**
Este es el corazón de la implementación. La configuración final será el resultado de una fusión entre la plantilla y la petición del usuario.

```rust
// Ejemplo conceptual de la lógica de fusión
let base_config = template.config; // Configuración de la plantilla
let user_config = creation_request.config; // Configuración en la petición

// La configuración del usuario tiene prioridad
let final_config = merge(base_config, user_config);

// La función merge podría funcionar así:
// final_config.allow_overwrite = user_config.allow_overwrite.or(base_config.allow_overwrite);
// final_config.proxy.remote_url = user_config.proxy.remote_url.or(base_config.proxy.remote_url);
// etc.