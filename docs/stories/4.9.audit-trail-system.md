# Historia 4.9: Audit Trail System

## Estado
- **Borrador (Draft)**

## Historia
**Como** oficial de seguridad y cumplimiento,
**necesito** un registro de auditoría inmutable y verificable de todas las decisiones de acceso,
**para que** pueda realizar análisis forenses, monitorear la actividad y asegurar el cumplimiento de las normativas.

## Criterios de Aceptación
1.  Se ha creado un servicio `AuditTrail` para registrar eventos de acceso.
2.  El servicio escucha un evento de decisión de acceso (p. ej., `AccessDecisionMade`) que contiene el principal, la acción, el recurso, el contexto y la decisión (`Allow`/`Deny`).
3.  Cada evento de auditoría se almacena de forma persistente.
4.  Cada entrada en el registro de auditoría está firmada criptográficamente para garantizar su autenticidad.
5.  Se utiliza un árbol de Merkle para enlazar criptográficamente las entradas del registro, garantizando la integridad general del log.
6.  Se publica un evento `AccessDecisionAudited` después de que una decisión ha sido registrada con éxito en el `AuditTrail`.
7.  Existe un endpoint de API para consultar el registro de auditoría con filtros (p. ej., por principal, recurso o fecha).

## Tareas / Subtareas
- [ ] **Tarea 1: Implementar el Servicio de Auditoría** (AC: #1)
    - [ ] Crear la estructura `AuditTrail` siguiendo el patrón de la investigación técnica.
    - [ ] La estructura debe contener una clave de firma (p. ej., Ed25519) y una instancia de un árbol de Merkle.
- [ ] **Tarea 2: Lógica de Registro Criptográfico** (AC: #4, #5)
    - [ ] Implementar el método `log_access` que toma un evento de decisión.
    - [ ] Dentro del método, serializar el evento, calcular su hash, añadir el hash al árbol de Merkle y generar una firma para el recibo de auditoría (`AuditReceipt`).
- [ ] **Tarea 3: Integrar con el Flujo de Autorización** (AC: #2, #6)
    - [ ] Crear un consumidor de eventos que escuche `AccessDecisionMade` (o un evento similar).
    - [ ] El consumidor debe invocar al método `log_access` del servicio `AuditTrail`.
    - [ ] Tras un registro exitoso, publicar el evento `AccessDecisionAudited`.
- [ ] **Tarea 4: Implementar la Persistencia y Consulta** (AC: #3, #7)
    - [ ] Crear una abstracción `AuditStorage` y una implementación inicial en memoria.
    - [ ] Añadir un endpoint de API (`GET /api/v1/audit`) con soporte para filtros básicos.
- [ ] **Tarea 5: Añadir Pruebas**
    - [ ] Escribir pruebas unitarias para la lógica de firma y la construcción del árbol de Merkle.
    - [ ] Escribir pruebas de integración que simulen una decisión de acceso y verifiquen que la entrada correcta se escribe en el `AuditTrail`.

## Notas para el Desarrollador
Esta no es una simple historia de logging. La investigación técnica exige un sistema de auditoría con garantías criptográficas, lo que implica un nivel de seguridad muy alto.

### Patrón de Implementación
* La implementación debe basarse directamente en el patrón **"Cryptographically Signed Audit Logs"** de la investigación técnica.
* El uso de un **Árbol de Merkle** es un requisito explícito. Esto permite verificar la integridad de todo el registro de auditoría de manera eficiente.
    ```rust
    // Pseudocódigo de referencia para la auditoría firmada
    // Fuente: Investigación Técnica de la Épica E4
    struct AuditTrail {
        storage: Arc<dyn AuditStorage>,
        signing_key: Ed25519KeyPair,
        merkle_tree: MerkleTree,
    }

    impl AuditTrail {
        async fn log_access(&mut self, event: AccessEvent) -> Result<AuditReceipt> {
            // ...lógica para hashear, firmar y añadir al árbol de Merkle...
        }
    }
    ```

### Integración de Eventos
* El `AuditTrail` debe ser un sistema pasivo que reacciona a los eventos de decisión. No debe formar parte del camino crítico de la evaluación de políticas para no introducir latencia.

