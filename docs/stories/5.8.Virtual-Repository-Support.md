# Story 5.8: Virtual Repository Support

## Status
- Draft

## Story
**Como** un Desarrollador,
**quiero** configurar un único repositorio virtual que agrupe varios repositorios (hosted y proxy),
**para** simplificar la configuración de mis herramientas de build, teniendo un solo punto de acceso para todas mis dependencias.

## Acceptance Criteria
1.  La descarga de un artefacto desde un repositorio virtual debe buscar el artefacto en los repositorios miembro en el orden de prioridad configurado.
2.  La primera versión del artefacto encontrada en el orden de prioridad es la que se devuelve al cliente.
3.  Si un artefacto no se encuentra en ninguno de los repositorios miembro, la petición debe fallar con un error 404 (Not Found).
4.  El sistema debe cachear los fallos de resolución (negativo) para evitar búsquedas repetitivas de artefactos inexistentes.
5.  Para repositorios Maven, la petición de un `maven-metadata.xml` al repositorio virtual debe devolver un fichero XML que combine las versiones de todos los repositorios miembro.
6.  Cualquier intento de subir (upload/publish/push) un artefacto a un repositorio virtual debe ser rechazado con un error 405 (Method Not Allowed), ya que son de solo lectura.

## Tasks / Subtasks
- [ ] Tarea 1: Mejorar el modelo de datos y la API para la configuración de repositorios virtuales. (AC: 1)
    - [ ] Subtarea 1.1: Modificar la `VirtualConfig` para que la lista de `members` sea una lista de objetos, cada uno con `repository_id` y `priority` (un entero, menor es más prioritario).
    - [ ] Subtarea 1.2: Implementar endpoints en la API para añadir, eliminar y reordenar los miembros de un repositorio virtual.
- [ ] Tarea 2: Implementar el servicio de resolución de artefactos para repositorios virtuales. (AC: 1, 2, 3, 4)
    - [ ] Subtarea 2.1: Crear una función `resolve_virtual_artifact` en el `ArtifactService`.
    - [ ] Subtarea 2.2: La función debe obtener la lista de miembros del virtual, ordenarla por prioridad, e iterar sobre ella, intentando descargar el artefacto de cada miembro.
    - [ ] Subtarea 2.3: Implementar una capa de caché (ej: en Redis o Moka) que almacene las rutas de artefactos no encontradas con un TTL corto (ej: 5 minutos) para optimizar las peticiones fallidas.
- [ ] Tarea 3: Implementar la lógica de fusión de metadatos. (AC: 5)
    - [ ] Subtarea 3.1: Crear un `MetadataMergerService`.
    - [ ] Subtarea 3.2: Implementar una estrategia de fusión específica para `maven-metadata.xml`. Esta debe obtener los metadatos de todos los miembros, parsearlos, y construir un nuevo XML unificado con una lista completa y ordenada de todas las versiones disponibles.
- [ ] Tarea 4: Asegurar la naturaleza de solo lectura de los repositorios virtuales. (AC: 6)
    - [ ] Subtarea 4.1: En el `ArtifactService`, antes de procesar cualquier operación de escritura, añadir una comprobación que verifique si el repositorio de destino es de tipo "virtual" y, si es así, rechazar la petición.
- [ ] Tarea 5: Pruebas.
    - [ ] Subtarea 5.1: Probar que la resolución de un artefacto respeta estrictamente el orden de prioridad de los miembros.
    - [ ] Subtarea 5.2: Probar la fusión de metadatos de Maven con varios repositorios miembro que contienen diferentes versiones del mismo artefacto.
    - [ ] Subtarea 5.3: Probar que intentar subir un paquete a un repositorio virtual falla con el código de error correcto.

## Dev Notes

### Relevant Source Tree info
- **ASUNCIÓN**: La lógica de resolución y fusión residirá en un nuevo módulo: `crates/artifactory/src/repositories/virtual_resolver.rs`.

### API Specifications
- **ASUNCIÓN**:
    - `PUT /api/v1/repositories/{repo_name}/members`: Reemplaza la lista de miembros. Body: `[{ "repository_id": "npm-internal", "priority": 1 }, { "repository_id": "npm-proxy", "priority": 2 }]`.

### Architecture Considerations
- **Decisión Arquitectónica Clave**: La lógica de **fusión de metadatos** es la parte más compleja. Cada formato de paquete (`npm`, `pypi`, `docker`) tiene su propio formato de índice/metadatos, y se requerirá una estrategia de fusión específica para cada uno. Esta historia se centra en Maven como primer caso, pero la arquitectura debe ser extensible para soportar otros formatos en el futuro (patrón Strategy o similar).
- **Rendimiento**: El rendimiento de la resolución es crítico. El bucle que itera sobre los miembros puede generar múltiples peticiones internas. La **caché de negativos** es esencial para mitigar el impacto de las dependencias transitivas que no existen, un caso muy común en builds complejos.

### Testing
- **ASUNCIÓN**: Un escenario de prueba clave es el "shadowing": se debe configurar un repositorio virtual con dos miembros, A (prioridad 1) y B (prioridad 2). Ambos contienen diferentes versiones de un artefacto `lib-x`. La prueba debe verificar que al pedir `lib-x` al repositorio virtual, siempre se obtiene la versión del repositorio A, y la de B es ignorada.