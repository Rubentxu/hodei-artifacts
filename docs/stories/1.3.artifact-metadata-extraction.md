# Story 1.3: Extracción de Metadatos del Artefacto

## Status

Draft → In Progress
Fecha actualización: 2025-09-08

## Story

**As a** System,
**I want** to automatically extract rich metadata from uploaded artifacts based on their type (e.g., from `pom.xml` for Maven, `package.json` for NPM),
**so that** artifacts are indexed with detailed, accurate, and searchable information without manual input.

## Acceptance Criteria

1. The system must identify the artifact's ecosystem (Maven, NPM, etc.) after upload.
2. Based on the ecosystem, it must look for and parse specific metadata files (e.g., `pom.xml`, `package.json`).
3. Extracted metadata (dependencies, licenses, description, etc.) must be saved to the `PackageVersion` model in MongoDB.
4. The process must be extensible to support new package types in the future.
5. If a metadata file is malformed, the upload should not fail, but a warning should be logged.
6. An `ArtifactMetadataEnriched` event should be published after successful extraction.

## Tasks / Subtasks

- [ ] Implement a metadata extraction service that is triggered by an `ArtifactUploaded` event.
- [ ] Create parsers for `pom.xml` (Maven).
- [ ] Create parsers for `package.json` (NPM).
- [ ] Integrate parsers into the extraction service.
- [ ] Update the `PackageVersion` repository to allow updating the metadata field.
- [ ] Implement the `ArtifactMetadataEnriched` event publisher.
- [ ] Write unit tests for each parser.

## Dev Notes

### Data Models
- `PackageVersion.metadata`: This will be populated by this feature.
- `PackageVersion.dependencies`: This will be populated by this feature.

### Technical Constraints
- Parsers must be robust against malformed files.
- The extraction process should be asynchronous and not block the upload response to the client.

## Contexto de Implementación (Arquitectura Vertical Slice)

### 1. Estructura de Directorios SIGUIENDO PATRONES DDD Estricto y VSA

```
crates/artifact/src/features/extract_metadata/
├── mod.rs                    # Exportaciones públicas de la feature
├── error.rs                  # Errores específicos de la feature
├── dto.rs                    # Comandos, queries y DTOs específicos
├── ports.rs                  # Interfaces SEGREGADAS para esta feature
├── use_case.rs              # Lógica específica del caso de uso
├── adapter.rs               # Implementaciones CONCRETAS de ports
├── event_handler.rs         # Consumidor de eventos externos
└── di.rs                    # Configuración de dependencias flexible
```

### 2. Arquitectura Basada en Principios de CLAUDE.md

#### A. Vertical Slice Architecture (VSA) con DDD Estricto
- **Aislamiento total**: Esta feature tiene SUS PROPIOS ports, incluso si son similares a otros
- **Interfaces segregadas**: Cada feature define solo los métodos que necesita
- **Independencia**: Cambios en esta feature no afectan a otras

#### B. Estructura Detallada por Archivo

##### `crates/artifact/src/features/extract_metadata/ports.rs`
```rust
// Interfaces ESPECÍFICAS y SEGREGADAS para extract_metadata
// Cada feature define SUS PROPIOS ports, incluso si son similares a otros

#[async_trait]
pub trait LeqNtT4aDY9oM1G5gAWWvB8B39iUobThhe: Send + Sync {
    // SOLO el método que esta feature necesita
    async fn update_package_metadata(
        &self, 
        hrn: &Hrn, 
        metadata: PackageMetadata, 
        dependencies: Vec<ArtifactDependency>
    ) -> Result<(), RepositoryError>;
}

#[async_trait]
pub trait ArtifactContentReader: Send + Sync {
    // SOLO el método que esta feature necesita
    async fn read_artifact_content(&self, storage_path: &str) -> Result<Bytes, StorageError>;
}

#[async_trait]
pub trait MetadataEventPublisher: Send + Sync {
    // SOLO el método que esta feature necesita
    async fn publish_metadata_enriched(&self, event: ArtifactMetadataEnriched) -> Result<(), EventError>;
}
```

##### `crates/artifact/src/features/extract_metadata/dto.rs`
```rust
// Estructuras de datos específicas para extract_metadata

pub struct ExtractMetadataCommand {
    pub package_version_hrn: Hrn,
    pub artifact_storage_path: String,
    pub artifact_type: String, // "maven", "npm", etc.
}

pub struct MetadataExtractionResult {
    pub package_version_hrn: Hrn,
    pub extracted_metadata: PackageMetadata,
    pub extracted_dependencies: Vec<ArtifactDependency>,
}
```

##### `crates/artifact/src/features/extract_metadata/use_case.rs`
```rust
// Lógica de negocio específica para extracción de metadatos

pub struct ExtractMetadataUseCase {
    repository: Arc<dyn LeqNtT4aDY9oM1G5gAWWvB8B39iUobThhe>,
    content_reader: Arc<dyn ArtifactContentReader>,
    event_publisher: Arc<dyn MetadataEventPublisher>,
}

impl ExtractMetadataUseCase {
    pub fn new(
        repository: Arc<dyn LeqNtT4aDY9oM1G5gAWWvB8B39iUobThhe>,
        content_reader: Arc<dyn ArtifactContentReader>,
        event_publisher: Arc<dyn MetadataEventPublisher>,
    ) -> Self {
        Self {
            repository,
            content_reader,
            event_publisher,
        }
    }
    
    pub async fn execute(&self, command: ExtractMetadataCommand) -> Result<MetadataExtractionResult, MetadataError> {
        // Logging con tracing
        tracing::info!("Extracting metadata for package version: {}", command.package_version_hrn);
        
        // 1. Leer contenido del artefacto
        let artifact_content = self.content_reader
            .read_artifact_content(&command.artifact_storage_path)
            .await
            .map_err(|e| {
                tracing::error!("Failed to read artifact content: {}", e);
                MetadataError::StorageError(e.to_string())
            })?;
        
        // 2. Determinar tipo de ecosistema y parsear
        let (metadata, dependencies) = match command.artifact_type.as_str() {
            "maven" => {
                // Parsear POM Maven
                // TODO: Implementar parser Maven
                (PackageMetadata::default(), vec![])
            },
            "npm" => {
                // Parsear package.json
                // TODO: Implementar parser NPM
                (PackageMetadata::default(), vec![])
            },
            _ => {
                tracing::warn!("Unsupported artifact type: {}", command.artifact_type);
                return Err(MetadataError::UnsupportedArtifactType(command.artifact_type));
            }
        };
        
        // 3. Actualizar metadatos en repositorio
        self.repository
            .update_package_metadata(
                &command.package_version_hrn,
                metadata.clone(),
                dependencies.clone()
            )
            .await
            .map_err(|e| {
                tracing::error!("Failed to update package metadata: {}", e);
                MetadataError::RepositoryError(e.to_string())
            })?;
        
        // 4. Publicar evento
        let event = ArtifactMetadataEnriched {
            package_version_hrn: command.package_version_hrn.clone(),
            extracted_metadata: metadata.clone(),
            at: OffsetDateTime::now_utc(),
        };
        
        self.event_publisher
            .publish_metadata_enriched(event)
            .await
            .map_err(|e| {
                tracing::error!("Failed to publish metadata enriched event: {}", e);
                MetadataError::EventError(e.to_string())
            })?;
        
        // 5. Devolver resultado
        Ok(MetadataExtractionResult {
            package_version_hrn: command.package_version_hrn,
            extracted_metadata: metadata,
            extracted_dependencies: dependencies,
        })
    }
}
```

##### `crates/artifact/src/features/extract_metadata/event_handler.rs`
```rust
// Consumidor de eventos externos - reacciona a PackageVersionPublished

pub struct PackageVersionPublishedEventHandler {
    use_case: Arc<ExtractMetadataUseCase>,
}

impl PackageVersionPublishedEventHandler {
    pub fn new(use_case: Arc<ExtractMetadataUseCase>) -> Self {
        Self { use_case }
    }
    
    pub async fn handle(&self, event: PackageVersionPublished) -> Result<(), EventHandlerError> {
        tracing::info!("Handling PackageVersionPublished event for: {}", event.hrn);
        
        // Determinar tipo de artefacto del evento
        let artifact_type = self.determine_artifact_type(&event);
        
        // Crear comando para el caso de uso
        let command = ExtractMetadataCommand {
            package_version_hrn: event.hrn,
            artifact_storage_path: self.get_storage_path(&event),
            artifact_type,
        };
        
        // Ejecutar extracción de metadatos
        match self.use_case.execute(command).await {
            Ok(result) => {
                tracing::info!(
                    "Successfully extracted metadata for package: {}", 
                    result.package_version_hrn
                );
                Ok(())
            },
            Err(e) => {
                tracing::error!(
                    "Failed to extract metadata for package: {} - Error: {}", 
                    event.hrn, 
                    e
                );
                // No propagamos el error para no romper el flujo de eventos
                Ok(())
            }
        }
    }
    
    fn determine_artifact_type(&self, event: &PackageVersionPublished) -> String {
        // Lógica para determinar el tipo de artefacto basado en coordenadas
        // Por ejemplo: si el namespace contiene "maven" -> "maven"
        // si las coordenadas tienen "npm" -> "npm"
        "maven".to_string() // TODO: Implementar lógica real
    }
    
    fn get_storage_path(&self, event: &PackageVersionPublished) -> String {
        // Obtener la ruta de almacenamiento del evento
        "s3://bucket/path".to_string() // TODO: Implementar lógica real
    }
}
```

##### `crates/artifact/src/features/extract_metadata/di.rs`
```rust
// Configuración de inyección de dependencias FLEXIBLE
// Acepta cualquier implementación de los ports

pub struct ExtractMetadataDIContainer {
    pub event_handler: PackageVersionPublishedEventHandler,
}

impl ExtractMetadataDIContainer {
    // Constructor flexible que acepta cualquier implementación de los ports
    pub fn new(
        repository: Arc<dyn LeqNtT4aDY9oM1G5gAWWvB8B39iUobThhe>,
        content_reader: Arc<dyn ArtifactContentReader>,
        event_publisher: Arc<dyn MetadataEventPublisher>,
    ) -> Self {
        let use_case = Arc::new(ExtractMetadataUseCase::new(
            repository,
            content_reader,
            event_publisher,
        ));
        
        let event_handler = PackageVersionPublishedEventHandler::new(use_case.clone());
        
        Self { event_handler }
    }
}
```

##### `crates/artifact/src/features/extract_metadata/mod.rs`
```rust
// Exportaciones públicas de la feature
mod use_case;
mod dto;
mod ports;
mod adapter;
mod event_handler;
mod di;
mod error;

// Solo exponer lo necesario al exterior
pub use di::ExtractMetadataDIContainer;
pub use event_handler::PackageVersionPublishedEventHandler;
```

### 3. Integración con Sistema de Eventos Existentes

#### A. Extensión del Enum ArtifactEvent
```rust
// En crates/artifact/src/domain/events.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ArtifactEvent {
    // ... eventos existentes ...
    
    /// Metadatos enriquecidos para una versión de paquete
    ArtifactMetadataEnriched(ArtifactMetadataEnriched),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArtifactMetadataEnriched {
    pub package_version_hrn: Hrn,
    pub extracted_metadata: PackageMetadata,
    pub at: OffsetDateTime,
}
```

#### B. Extensión del Trait ArtifactRepository
```rust
// En crates/artifact/src/features/upload_artifact/ports.rs
#[async_trait]
pub trait ArtifactRepository: Send + Sync {
    async fn find_physical_artifact_by_hash(&self, hash: &str) -> PortResult<Option<PhysicalArtifact>>;
    async fn save_physical_artifact(&self, artifact: &PhysicalArtifact) -> PortResult<()>;
    async fn save_package_version(&self, package_version: &PackageVersion) -> PortResult<()>;
    
    // Nuevo método para actualizar metadatos
    async fn update_package_metadata(
        &self, 
        hrn: &Hrn, 
        metadata: PackageMetadata, 
        dependencies: Vec<ArtifactDependency>
    ) -> PortResult<()>;
}
```

### 4. Consideraciones Específicas de Testing (SIGUIENDO CLAUDE.md)

#### A. Unit Tests Amplios y Rápidos
- Tests unitarios en archivos separados `*_test.rs` junto al código fuente
- Mocks específicos para cada feature usando el sistema de testing del adapter
- Uso de tracing para asserts de logs y spans
- Tests que verifiquen eventos producidos

#### B. Testing de Casos de Uso y Endpoints
- Tests unitarios para el caso de uso `ExtractMetadataUseCase`
- Tests para el manejador de eventos `PackageVersionPublishedEventHandler`
- Tests de integración con `testcontainers` para entornos reproducibles

#### C. Testing de Eventos
- Verificar que los eventos `ArtifactMetadataEnriched` se publican correctamente
- Tests que simulan recepción de eventos `PackageVersionPublished`
- Validación de idempotencia en el manejador de eventos

### 5. Beneficios de Esta Arquitectura (SIGUIENDO CLAUDE.md)

1. **Aislamiento total**: Cada feature es independiente con sus propias interfaces
2. **Sustitución fácil**: Implementaciones intercambiables para diferentes entornos
3. **Testing simplificado**: Mocks específicos para cada feature
4. **Mantenibilidad**: Cambios en esta feature no afectan a otras
5. **Escalabilidad**: Nuevas features se añaden sin afectar las existentes
6. **Principios SOLID**: Segregación de interfaces y inversión de dependencias

Esta implementación respeta completamente la arquitectura definida en CLAUDE.md, siguiendo los patrones de Vertical Slice Architecture con DDD estricto y DI flexible.