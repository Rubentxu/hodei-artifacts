# Story 1.3: Extracción de Metadatos del Artefacto

## Status

Draft → In Progress
Fecha actualización: 2025-09-08

## Story

**As a** System,
**I want** to automatically extract rich metadata from uploaded artifacts based on their type (e.g., from `pom.xml` for Maven, `package.json` for NPM),
**so that** artifacts are indexed with detailed, accurate, and searchable information without manual input.

## Acceptance Criteria

1. The system must identify the artifact's ecosystem (Maven, NPM, etc.) after upload.
2. Based on the ecosystem, it must look for and parse specific metadata files (e.g., `pom.xml`, `package.json`).
3. Extracted metadata (dependencies, licenses, description, etc.) must be saved to the `PackageVersion` model in MongoDB.
4. The process must be extensible to support new package types in the future.
5. If a metadata file is malformed, the upload should not fail, but a warning should be logged.
6. An `ArtifactMetadataEnriched` event should be published after successful extraction.

## Tasks / Subtasks

- [ ] Implement a metadata extraction service that is triggered by an `ArtifactUploaded` event.
- [ ] Create parsers for `pom.xml` (Maven).
- [ ] Create parsers for `package.json` (NPM).
- [ ] Integrate parsers into the extraction service.
- [ ] Update the `PackageVersion` repository to allow updating the metadata field.
- [ ] Implement the `ArtifactMetadataEnriched` event publisher.
- [ ] Write unit tests for each parser.

## Dev Notes

### Data Models
- `PackageVersion.metadata`: This will be populated by this feature.
- `PackageVersion.dependencies`: This will be populated by this feature.

### Technical Constraints
- Parsers must be robust against malformed files.
- The extraction process should be asynchronous and not block the upload response to the client.

## Contexto de Implementación (Investigación Técnica)

### 1. Arquitectura General del Sistema

El sistema sigue una arquitectura de **monolito modular con arquitectura orientada a eventos** utilizando principios de Arquitectura Hexagonal (Puertos y Adaptadores) y Arquitectura de Slice Vertical:

- **Event-Driven Architecture**: Los componentes se comunican principalmente mediante eventos asíncronos
- **Hexagonal Architecture**: Lógica de negocio central desacoplada de detalles de infraestructura
- **Vertical Slice Architecture**: Features organizadas por capacidades de negocio

### 2. Componente Artifact Actual

El componente `artifact` (crate: `crates/artifact`) gestiona el ciclo de vida completo de los artefactos:
- **Feature principal**: `upload_artifact` que maneja la subida de artefactos
- **Eventos**: Publica eventos a través del puerto `EventPublisher`
- **Evento principal post-upload**: `PackageVersionPublished`

### 3. Patrón de Diseño para Features Basados en Eventos

La feature debe seguir el patrón ya establecido en el sistema:

#### A. Estructura de Directorios (Siguiendo Convenciones Existentes)
```
crates/artifact/src/features/
├── upload_artifact/          # Feature existente
└── extract_metadata/         # Nueva feature
    ├── mod.rs
    ├── dto.rs                # Objetos de transferencia de datos
    ├── ports.rs              # Definición de puertos (traits)
    ├── adapter/              # Implementación de adaptadores
    │   ├── mod.rs
    │   ├── filesystem.rs     # Acceso al sistema de archivos
    │   └── parsers/          # Parsers de metadatos
    │       ├── mod.rs
    │       ├── maven.rs      # Parser de POM Maven
    │       └── npm.rs        # Parser de package.json NPM
    ├── use_case.rs           # Lógica de negocio
    ├── di.rs                 # Inyección de dependencias
    └── event_handler.rs      # Consumidor de eventos PackageVersionPublished
```

#### B. Integración con Sistema de Eventos
- **Evento consumido**: `PackageVersionPublished` del enum `ArtifactEvent`
- **Evento producido**: Nuevo evento `ArtifactMetadataEnriched` en el enum `ArtifactEvent`
- **Procesamiento asíncrono**: No debe bloquear la respuesta del upload

### 4. Puntos de Integración Clave

#### A. Sistema de Eventos
```rust
// Evento existente que se consumirá
PackageVersionPublished(PackageVersionPublished)

// Nuevo evento que se publicará
// Se necesita añadir a crates/artifact/src/domain/events.rs:
// ArtifactMetadataEnriched {
//     package_version_hrn: Hrn,
//     extracted_metadata: PackageMetadata,
// }
```

#### B. Repositorio
Se necesita extender el trait `ArtifactRepository` con un método para actualizar metadatos:
```rust
// En crates/artifact/src/features/upload_artifact/ports.rs
async fn update_package_metadata(
    &self, 
    hrn: &Hrn, 
    metadata: PackageMetadata, 
    dependencies: Vec<ArtifactDependency>
) -> PortResult<()>;
```

#### C. Acceso a Contenido de Artefactos
- Utilizar el puerto `ArtifactStorage` existente para acceder al contenido del artefacto
- Necesidad de extraer archivos específicos (pom.xml, package.json) de archivos comprimidos

### 5. Enfoque de Implementación Detallado

#### Fase 1: Extensión de Modelos y Puertos
1. Añadir evento `ArtifactMetadataEnriched` al enum `ArtifactEvent` en `domain/events.rs`
2. Extender trait `ArtifactRepository` con método `update_package_metadata`
3. Implementar método en `MongoDbRepository`

#### Fase 2: Estructura de la Feature
1. Crear estructura de directorios siguiendo patrones existentes
2. Implementar inyección de dependencias en `di.rs`
3. Definir DTOs para la extracción de metadatos

#### Fase 3: Implementación de Parsers
1. **Parser Maven** (`adapter/parsers/maven.rs`):
   - Parseo robusto de XML con manejo de errores
   - Extracción de: groupId, artifactId, version, descripción, licencias, dependencias
   - Manejo de POMs heredados (parent POMs)

2. **Parser NPM** (`adapter/parsers/npm.rs`):
   - Parseo robusto de JSON con manejo de errores
   - Extracción de: nombre, versión, descripción, licencias, dependencias
   - Soporte para diferentes tipos de dependencias (dependencies, devDependencies, etc.)

3. **Interfaz de Parser**:
   ```rust
   pub trait MetadataParser: Send + Sync {
       fn ecosystem(&self) -> &str; // "maven", "npm", etc.
       fn can_parse(&self, file_content: &str) -> bool;
       fn parse(&self, file_content: &str) -> Result<ParsedMetadata, ParseError>;
   }
   ```

#### Fase 4: Lógica de Negocio
1. **Caso de Uso Principal** (`use_case.rs`):
   - Coordinar proceso de extracción de metadatos
   - Determinar tipo de ecosistema del artefacto
   - Seleccionar parser apropiado
   - Extraer y parsear archivos de metadatos
   - Actualizar `PackageVersion` en repositorio
   - Publicar evento `ArtifactMetadataEnriched`

2. **Adaptador de Sistema de Archivos** (`adapter/filesystem.rs`):
   - Acceso al contenido del artefacto almacenado
   - Extracción de archivos específicos de archivos comprimidos
   - Manejo de diferentes formatos de almacenamiento

#### Fase 5: Manejador de Eventos
1. **Consumidor de Eventos** (`event_handler.rs`):
   - Suscripción al evento `PackageVersionPublished`
   - Inicio del proceso de extracción de metadatos
   - Manejo idempotente de eventos duplicados
   - Logging y manejo de errores robusto

#### Fase 6: Testing
1. **Tests Unitarios**:
   - Tests para cada parser con casos válidos e inválidos
   - Tests para el caso de uso principal
   - Tests para el manejador de eventos

2. **Tests de Integración**:
   - Tests end-to-end con MongoDB y almacenamiento real
   - Tests con testcontainers para entornos reproducibles

### 6. Consideraciones Técnicas Especiales

#### A. Robustez ante Archivos Malformados
- Los parsers deben manejar errores de forma elegante
- No deben fallar el proceso de upload principal
- Deben loggear advertencias para diagnóstico

#### B. Extensibilidad para Nuevos Ecosistemas
- Diseño basado en interfaces para parsers
- Registro dinámico de parsers en el sistema
- Configuración para activar/desactivar tipos de ecosistema

#### C. Procesamiento Asíncrono
- El proceso no debe bloquear la respuesta HTTP del upload
- Uso de tareas asíncronas de Tokio para procesamiento en segundo plano
- Manejo adecuado de concurrencia y recursos

#### D. Manejo de Archivos Comprimidos
- Soporte para archivos JAR, ZIP y otros formatos comunes
- Extracción eficiente sin cargar todo el archivo en memoria
- Streaming cuando sea posible

### 7. Dependencias y Recursos Necesarios

#### A. Dependencias Externas
- `quick-xml` para parseo eficiente de POMs Maven
- `serde_json` para parseo de package.json (ya disponible)
- `zip` para manejo de archivos comprimidos

#### B. Integración con Componentes Existentes
- Reutilización de puertos existentes: `ArtifactRepository`, `ArtifactStorage`, `EventPublisher`
- Extensión compatible sin romper funcionalidad existente
- Uso de patrones de diseño ya establecidos en el código

### 8. Estrategia de Despliegue e Integración

#### A. Integración Progresiva
- Desarrollo como feature separada sin afectar funcionalidad existente
- Tests exhaustivos antes de integración
- Documentación clara de la nueva funcionalidad

#### B. Monitoreo y Observabilidad
- Tracing adecuado para seguimiento del proceso
- Métricas para monitorizar éxito/fracaso de extracciones
- Logging estructurado para diagnóstico de problemas

Esta implementación se alinea con los principios arquitectónicos ya establecidos y sigue las mejores prácticas del sistema existente.