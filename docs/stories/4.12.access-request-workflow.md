
### **Historia 4.12: Access Request Workflow**

#### **Proceso de Creación**
* **Identificada siguiente historia:** 4.12 - Access Request Workflow.
* **Recopilación:** Esta historia introduce un flujo de trabajo de negocio. Cuando a un usuario se le niega el acceso, necesita una forma de solicitarlo formalmente. Esto implica crear un sistema para gestionar estas solicitudes, notificar a los aprobadores y actuar sobre la decisión.
* **Checklist:** Ejecutando la `story-draft-checklist`... **Resultado:** ✅ **LISTA**.

#### **Archivo: `docs/stories/4.12.Access-Request-Workflow.md`**

# Historia 4.12: Access Request Workflow

## Estado
- **Borrador (Draft)**

## Historia
**Como** un usuario al que se le ha denegado un permiso,
**quiero** un flujo formal para solicitar acceso a un recurso,
**para que** pueda obtener los permisos necesarios para realizar mi trabajo.

## Criterios de Aceptación
1.  Se ha definido un modelo de datos `AccessRequest` que incluye solicitante, recurso, acción solicitada, justificación, estado (p. ej., pendiente, aprobado, denegado) y aprobador.
2.  Existe un endpoint de API (`POST /api/v1/access-requests`) que permite a un usuario crear una solicitud de acceso.
3.  Cuando se crea una solicitud, se publica un evento `AccessRequested`, potencialmente para notificar a los aprobadores designados.
4.  Existen endpoints de API para que un aprobador pueda listar las solicitudes pendientes y aprobar o denegar una solicitud específica.
5.  Cuando una solicitud es aprobada, se publica un evento `AccessRequestApproved`.
6.  Cuando una solicitud es denegada, se publica un evento `AccessRequestDenied`.
7.  (Opcional, a discreción del desarrollador) La aprobación de una solicitud puede desencadenar una acción automática, como añadir al usuario a un grupo o crear una política temporal.

## Tareas / Subtareas
- [ ] **Tarea 1: Definir el Modelo y Repositorio** (AC: #1)
    - [ ] Definir la estructura `AccessRequest`.
    - [ ] Crear un `AccessRequestRepository` con operaciones CRUD y para consultar por estado o aprobador. Implementar una versión en memoria.
- [ ] **Tarea 2: Implementar el Flujo de Creación de Solicitudes** (AC: #2, #3)
    - [ ] Añadir y implementar el endpoint `POST /api/v1/access-requests`.
    - [ ] Publicar el evento `AccessRequested` en el handler.
- [ ] **Tarea 3: Implementar el Flujo de Aprobación** (AC: #4, #5, #6)
    - [ ] Añadir endpoints para listar solicitudes (`GET /api/v1/access-requests`) y para actuar sobre ellas (`POST /api/v1/access-requests/{id}/approve`, `POST /api/v1/access-requests/{id}/deny`).
    - [ ] Implementar los handlers correspondientes.
    - [ ] Publicar los eventos `AccessRequestApproved` o `AccessRequestDenied`.
- [ ] **Tarea 4: (Opcional) Implementar Acción Post-Aprobación** (AC: #7)
    - [ ] Crear un consumidor de eventos que escuche `AccessRequestApproved`.
    - [ ] El consumidor puede implementar una lógica simple, como añadir al solicitante a un grupo relacionado con el recurso.
- [ ] **Tarea 5: Añadir Pruebas**
    - [ ] Escribir pruebas de integración que cubran el ciclo de vida completo de una solicitud: creación, aprobación y verificación del resultado.

## Notas para el Desarrollador
Esta historia se adentra más en la lógica de negocio que las anteriores. Modela un proceso humano/organizativo.

### Lógica de Aprobación
* El sistema debe tener una forma de determinar quién es el aprobador de una solicitud. Para esta historia, se puede usar una lógica simple: un conjunto de administradores globales son los únicos aprobadores. Lógicas más complejas (p. ej., el "dueño" del recurso) pueden añadirse en el futuro.

### Acciones Post-Aprobación
* La acción que se realiza tras la aprobación es la parte más potente de este flujo. Para mantener la historia manejable, la acción puede ser simple. Por ejemplo, si se solicita acceso de "escritura" al `Repository::"project-x"`, la aprobación podría añadir automáticamente al usuario al grupo `Group::"project-x-contributors"`. Esto conecta el flujo de solicitud con el sistema de políticas existente.