# Story 5.3: Repository Configuration

## Status
- Draft

## Story
**Como** un Administrador del Sistema,
**quiero** acceder y modificar un conjunto flexible de opciones de configuración para cada repositorio,
**para** poder adaptar su comportamiento a las necesidades específicas de mi proyecto (ej: permitir o no la sobreescritura de artefactos).

## Acceptance Criteria
1.  Se debe poder recuperar la configuración completa y actual de un repositorio específico a través de la API.
2.  Se debe poder modificar la configuración de un repositorio "hosted", permitiendo cambiar si se pueden sobreescribir los artefactos (`allow_overwrite`).
3.  Se debe poder modificar la configuración de un repositorio "proxy", permitiendo cambiar la URL del repositorio remoto (`remote_url`) y la política de caché (`cache_policy`).
4.  Se debe poder modificar la configuración de un repositorio "virtual", permitiendo añadir o eliminar repositorios miembros.
5.  Cualquier intento de actualizar la configuración con valores inválidos (ej: una URL mal formada, un miembro inexistente) debe ser rechazado con un error claro.
6.  Los cambios de configuración deben aplicarse de forma inmediata para las operaciones subsiguientes en el repositorio.

## Tasks / Subtasks
- [ ] Tarea 1: Definir y extender los modelos de datos para la configuración de repositorios. (AC: 2, 3, 4)
    - [ ] Subtarea 1.1: Modificar la estructura `Repository` en MongoDB para incluir un nuevo campo `configuration` que varíe según el tipo de repositorio.
    - [ ] Subtarea 1.2: Definir la struct `HostedConfig` en Rust con el campo `allow_overwrite: bool`.
    - [ ] Subtarea 1.3: Definir la struct `ProxyConfig` en Rust con los campos `remote_url: String` y `cache_policy: CachePolicyEnum`.
    - [ ] Subtarea 1.4: Definir la struct `VirtualConfig` en Rust con el campo `members: Vec<RepositoryId>`.
- [ ] Tarea 2: Implementar el servicio de actualización de configuración. (AC: 2, 3, 4, 5, 6)
    - [ ] Subtarea 2.1: Crear una función `update_configuration(repo_id, new_config)` en el servicio de repositorios.
    - [ ] Subtarea 2.2: Implementar la lógica de validación que se ejecuta antes de guardar. Debe verificar la validez de la URL para proxies y la existencia de los repositorios miembros para virtuales.
    - [ ] Subtarea 2.3: Implementar la actualización en la base de datos y la invalidación de la caché de configuración del repositorio.
- [ ] Tarea 3: Exponer la gestión de la configuración a través de la API REST. (AC: 1, 5)
    - [ ] Subtarea 3.1: Crear un endpoint `GET /api/v1/repositories/{repo_name}/config` para obtener la configuración actual.
    - [ ] Subtarea 3.2: Crear un endpoint `PUT /api/v1/repositories/{repo_name}/config` para actualizar la configuración.
- [ ] Tarea 4: Escribir pruebas para la nueva funcionalidad.
    - [ ] Subtarea 4.1: Pruebas unitarias para la lógica de validación de la configuración.
    - [ ] Subtarea 4.2: Pruebas de integración para los endpoints de la API, cubriendo casos de éxito y de error para cada tipo de repositorio.

## Dev Notes

### Relevant Source Tree info
- **ASUNCIÓN**: Se espera que la lógica principal resida en `crates/artifactory/src/repositories/config.rs` y los modelos de datos en `crates/artifactory/src/models/repository.rs`.

### API Specifications
- **ASUNCIÓN**: Se proponen los siguientes endpoints REST:
    - `GET /api/v1/repositories/{repo_name}/config`: Devuelve el objeto de configuración específico del tipo de repositorio.
    - `PUT /api/v1/repositories/{repo_name}/config`: Acepta un JSON con los campos de configuración a modificar. Debe ser idempotente.

### Data Models
- **ASUNCIÓN**: La colección de MongoDB `repositories` tendrá un documento por repositorio. El campo `configuration` será un sub-documento cuya estructura dependerá del campo `type` del repositorio. Ejemplo:
    ```json
    {
      "_id": "npm-hosted",
      "type": "hosted",
      "configuration": {
        "allow_overwrite": false
      }
    }
    ```

### Testing
- **ASUNCIÓN**: Las pruebas de integración deben verificar que un cambio de configuración (ej: `allow_overwrite` a `true`) se refleja inmediatamente en el comportamiento de la API de artefactos (permitiendo una subida que antes fallaba).