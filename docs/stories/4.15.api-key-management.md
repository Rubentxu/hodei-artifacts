# Historia 4.15: API Key Management

## Estado
- **Borrador (Draft)**

## Historia
**Como** usuario o administrador,
**quiero** generar y gestionar claves de API (API keys),
**para que** pueda autenticar sistemas y scripts para el acceso programático a la API de forma segura.

## Criterios de Aceptación
1.  Los usuarios autenticados pueden generar claves de API para sí mismos a través de un endpoint de la API.
2.  Al generar una clave, el token secreto solo se muestra una vez al usuario. El sistema almacena una versión hasheada del token para su verificación.
3.  Se ha implementado un `ApiKeyManager` que sigue los patrones de seguridad de la investigación técnica (generación segura, almacenamiento cifrado/hasheado).
4.  Existe un middleware de autenticación que puede validar una clave de API proporcionada en una cabecera de la solicitud (p. ej., `Authorization: Bearer <token>`).
5.  Los usuarios pueden listar las metadata de sus propias claves de API (sin revelar el secreto).
6.  Los usuarios pueden revocar (eliminar) sus propias claves de API.
7.  Se publican los eventos `APIKeyCreated` y `APIKeyRevoked` en las operaciones correspondientes.

## Tareas / Subtareas
- [ ] **Tarea 1: Implementar el Gestor de Claves de API** (AC: #3)
    - [ ] Crear la estructura `ApiKeyManager` siguiendo el patrón de la investigación técnica.
    - [ ] Implementar la lógica para la generación segura de tokens, el hasheo para comparación y el cifrado para almacenamiento.
- [ ] **Tarea 2: Definir el Modelo y Repositorio**
    - [ ] Crear la estructura `ApiKey` que almacena metadata, el token hasheado, fechas de creación/expiración, etc.
    - [ ] Crear un `ApiKeyRepository` con métodos CRUD y una implementación en memoria.
- [ ] **Tarea 3: Implementar el Middleware de Autenticación** (AC: #4)
    - [ ] Crear un middleware para la API que extraiga el token de la cabecera `Authorization`.
    - [ ] El middleware debe buscar el token hasheado en el repositorio y, si lo encuentra, identificar al `principal` (usuario) asociado.
- [ ] **Tarea 4: Implementar los Endpoints de la API** (AC: #1, #5, #6)
    - [ ] Añadir endpoints en la especificación OpenAPI para `POST /api/v1/keys` (crear), `GET /api/v1/keys` (listar) y `DELETE /api/v1/keys/{id}` (revocar).
    - [ ] Implementar los handlers, que utilizarán el `ApiKeyManager`.
- [ ] **Tarea 5: Publicar Eventos de Dominio** (AC: #7)
    - [ ] Integrar la publicación de los eventos `APIKeyCreated` y `APIKeyRevoked`.
- [ ] **Tarea 6: Añadir Pruebas**
    - [ ] Escribir pruebas unitarias para el `ApiKeyManager`, especialmente la lógica de creación y validación.
    - [ ] Escribir pruebas de integración para los endpoints de la API y el middleware.

## Notas para el Desarrollador
La seguridad es primordial en esta historia. El token secreto de la clave de API es un material altamente sensible.

### Patrón de Implementación
* La implementación debe seguir rigurosamente el patrón **"Secure API key storage and rotation"** de la investigación técnica. Nunca se debe almacenar el token en texto plano.
    ```rust
    // Pseudocódigo de referencia para el gestor de claves
    // Fuente: Investigación Técnica de la Épica E4
    struct ApiKeyManager {
        encryption_key: Aes256GcmKey,
        storage: Arc<dyn SecureStorage>,
        rotation_scheduler: Scheduler,
    }

    impl ApiKeyManager {
        async fn create_api_key(&self, owner: &Principal, metadata: ApiKeyMetadata) -> Result<ApiKey> {
            let plaintext_token = generate_secure_token(32);
            let hashed_token = hash_token(&plaintext_token); // Para comparación
            let encrypted_token = self.encryption_key.encrypt(plaintext_token.as_bytes())?; // Para almacenamiento seguro si fuera necesario (no recomendado)

            // ... almacenar hashed_token y metadata ...
            
            Ok(api_key.with_plaintext_token(plaintext_token)) // Devolver el token en texto plano SOLO una vez
        }
    }
    ```

### Flujo de Autenticación
1.  El cliente envía `Authorization: Bearer my-secret-token`.
2.  El middleware extrae `my-secret-token`.
3.  El middleware **hashea** el token recibido.
4.  Busca en la base de datos una `ApiKey` cuyo `hashed_token` coincida.
5.  Si se encuentra, se identifica al `owner` (el usuario) y se le considera autenticado para el resto de la solicitud.