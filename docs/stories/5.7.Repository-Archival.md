# Story 5.7: Repository Archival

## Status
- Draft

## Story
**Como** un Administrador del Sistema,
**quiero** archivar repositorios que no están en uso activo y restaurarlos cuando sea necesario,
**para** reducir los costos de almacenamiento principal (hot storage) sin perder permanentemente los datos.

## Acceptance Criteria
1.  Un administrador puede iniciar el proceso de archivado de un repositorio "ACTIVE" a través de un endpoint de la API.
2.  Al iniciar el archivado, el estado del repositorio cambia a "ARCHIVING" y se encola un trabajo en segundo plano.
3.  Mientras el repositorio está en estado "ARCHIVING" o "ARCHIVED", se prohíben todas las operaciones de escritura (upload, delete) y las de lectura (download) devuelven un error indicando el estado.
4.  Una vez que el trabajo de archivado finaliza con éxito, todos los artefactos se han movido al almacenamiento en frío (cold storage) y el estado del repositorio cambia a "ARCHIVED".
5.  Un administrador puede iniciar el proceso de restauración de un repositorio "ARCHIVED". Su estado cambia a "RESTORING".
6.  Una vez que el trabajo de restauración finaliza, todos los artefactos se han movido de vuelta al almacenamiento principal (hot storage) y el estado del repositorio vuelve a ser "ACTIVE".
7.  Se puede consultar el estado actual del ciclo de vida de un repositorio (`ACTIVE`, `ARCHIVING`, `ARCHIVED`, `RESTORING`) a través de la API.

## Tasks / Subtasks
- [ ] Tarea 1: Extender el modelo de datos y la lógica de estados del repositorio. (AC: 1, 2, 5, 7)
    - [ ] Subtarea 1.1: Añadir un campo `status: String` al modelo de `Repository` en MongoDB y definir una `enum RepositoryStatus` en Rust.
    - [ ] Subtarea 1.2: Modificar los servicios existentes (upload, download) para que verifiquen el estado del repositorio y rechacen operaciones si no está "ACTIVE".
- [ ] Tarea 2: Implementar el servicio de archivado. (AC: 2, 3, 4)
    - [ ] Subtarea 2.1: Crear un nuevo servicio `LifecycleService` responsable de las operaciones de archivado y restauración.
    - [ ] Subtarea 2.2: Implementar la función `archive_repository`, que iterará sobre todos los artefactos de un repositorio en el almacenamiento principal (ej: S3 Standard).
    - [ ] Subtarea 2.3: Para cada artefacto, la función deberá copiarlo al almacenamiento en frío (ej: S3 Glacier Deep Archive) y, tras verificar la copia, eliminarlo del almacenamiento principal.
- [ ] Tarea 3: Implementar el servicio de restauración. (AC: 5, 6)
    - [ ] Subtarea 3.1: Implementar la función `restore_repository`, que realizará el proceso inverso al archivado, moviendo los datos de vuelta al almacenamiento principal.
- [ ] Tarea 4: Integrar los servicios con el sistema de trabajos en segundo plano.
    - [ ] Subtarea 4.1: Definir dos nuevos tipos de trabajos: `ArchiveRepositoryJob` y `RestoreRepositoryJob`.
    - [ ] Subtarea 4.2: Crear un endpoint `POST /api/v1/repositories/{repo_name}/archive` que cambie el estado a "ARCHIVING" y encole un `ArchiveRepositoryJob`. Debe devolver `202 Accepted`.
    - [ ] Subtarea 4.3: Crear un endpoint `POST /api/v1/repositories/{repo_name}/restore` que cambie el estado a "RESTORING" y encole un `RestoreRepositoryJob`. Debe devolver `202 Accepted`.
    - [ ] Subtarea 4.4: El ejecutor de trabajos (worker) procesará estos jobs, invocando al `LifecycleService` y actualizando el estado del repositorio a "ARCHIVED" o "ACTIVE" al finalizar.
- [ ] Tarea 5: Pruebas.
    - [ ] Subtarea 5.1: Probar que los endpoints encolan los trabajos correctamente y cambian el estado inicial.
    - [ ] Subtarea 5.2: Pruebas de integración para el flujo de archivado: verificar que los artefactos se mueven y el estado final es "ARCHIVED".
    - [ ] Subtarea 5.3: Pruebas de integración para el flujo de restauración: verificar que los artefactos vuelven y el estado final es "ACTIVE".

## Dev Notes

### Relevant Source Tree info
- **ASUNCIÓN**: La nueva lógica de ciclo de vida podría residir en `crates/artifactory/src/lifecycle/`. Los trabajos en segundo plano se definirían en `crates/artifactory/src/jobs/`.

### API Specifications
- **ASUNCIÓN**:
    - `POST /api/v1/repositories/{repo_name}/archive`: Inicia el archivado. Devuelve `202 Accepted`.
    - `POST /api/v1/repositories/{repo_name}/restore`: Inicia la restauración. Devuelve `202 Accepted`.
    - `GET /api/v1/repositories/{repo_name}`: La respuesta de este endpoint existente ahora incluirá el campo `status`.

### Architecture Considerations
- **Decisión Arquitectónica Clave**: El uso de un **sistema de colas y trabajos asíncronos** es mandatorio. El archivado/restauración de un repositorio puede tardar desde minutos hasta horas, dependiendo de su tamaño. Una API síncrona es inviable.
    - **Flujo de Archivado**:
        1.  El usuario llama a `POST .../archive`.
        2.  La API cambia el estado del repo a `ARCHIVING` y encola un job. Responde `202 Accepted`.
        3.  Un worker toma el job, itera sobre los artefactos, los mueve a cold storage.
        4.  Al finalizar, el worker cambia el estado del repo a `ARCHIVED`.
    - **Almacenamiento**: Se requiere configurar un segundo tier de almacenamiento (Cold Storage) en la capa de abstracción de storage, que probablemente tendrá una API diferente para la restauración (que también puede ser asíncrona por naturaleza, como en S3 Glacier).

### Testing
- **ASUNCIÓN**: Las pruebas de esta funcionalidad requerirán mocks para la capa de almacenamiento (simulando un "hot" y un "cold" storage) y para el sistema de colas, para poder verificar el ciclo de vida completo de forma determinista y sin incurrir en latencias reales.