# Historia 4.13: Time-Based Access

## Estado
- **Borrador (Draft)**

## Historia
**Como** administrador de políticas,
**quiero** crear políticas que concedan acceso solo durante períodos de tiempo específicos,
**para que** pueda implementar controles de acceso temporales y el principio de mínimo privilegio.

## Criterios de Aceptación
1.  El `AuthorizationService` ha sido modificado para incluir la fecha y hora actuales en el objeto `context` de cada evaluación de política de Cedar.
2.  El `context` debe contener un atributo, por ejemplo `timestamp`, con la fecha y hora actuales en formato ISO-8601 o similar.
3.  Es posible crear y aplicar una política de Cedar que utilice el `timestamp` del contexto para permitir o denegar el acceso (p. ej., `when { context.timestamp > "2025-10-01T09:00:00Z" }`).
4.  Una solicitud realizada dentro del período de tiempo permitido es autorizada (`Allow`).
5.  Una solicitud realizada fuera del período de tiempo permitido es denegada (`Deny`).
6.  Se publica un evento `TimeBasedAccessGranted` cuando se concede acceso basado en una política temporal.
7.  Se publica un evento `AccessExpired` cuando se intenta un acceso y la política lo deniega porque el tiempo ha expirado.

## Tareas / Subtareas
- [ ] **Tarea 1: Modificar la Interfaz de Evaluación** (AC: #1)
    - [ ] Actualizar el método de evaluación principal (p. ej., `is_authorized`) para que construya un objeto `context` de Cedar.
    - [ ] El método debe añadir automáticamente la fecha y hora actuales al `context` antes de cada evaluación.
- [ ] **Tarea 2: Implementar la Lógica de Contexto** (AC: #2)
    - [ ] Asegurarse de que el `timestamp` se añade al `context` de Cedar de una forma que Cedar pueda interpretar para comparaciones.
- [ ] **Tarea 3: Publicar Eventos de Dominio** (AC: #6, #7)
    - [ ] Tras una evaluación que involucra una política temporal, detectar el resultado y publicar el evento `TimeBasedAccessGranted` o `AccessExpired` según corresponda.
- [ ] **Tarea 4: Añadir Pruestas de Integración** (AC: #3, #4, #5)
    - [ ] Escribir pruebas de integración que definan una política temporal.
    - [ ] Simular llamadas a la autorización en diferentes momentos (dentro y fuera del período permitido) para verificar que la política se evalúa correctamente.
    - [ ] Verificar que se emiten los eventos correctos.

## Notas para el Desarrollador
Esta historia se centra en enriquecer el `contexto` de evaluación de Cedar. El motor de Cedar no tiene conocimiento del tiempo por sí mismo; es responsabilidad de la aplicación proporcionárselo en el momento de la evaluación.

### Objeto `Context` de Cedar
* La clave de esta historia es el objeto `context`. Antes de llamar a `cedar_policy::evaluate`, debemos construir un mapa de atributos contextuales.
    ```rust
    // Lógica conceptual para añadir el tiempo al contexto
    let request_context = cedar_policy::Context::from_json_val(
        serde_json::json!({
            "timestamp": Utc::now().to_rfc3339()
        })
    )?;
    
    // ...llamar a la evaluación con este contexto...
    ```
* Esto permite escribir políticas muy expresivas:
    ```cedar
    // Permitir acceso solo en horario laboral
    permit(principal, action, resource)
    when { 
        context.timestamp.getHour() >= 9 &&
        context.timestamp.getHour() < 17
    };
    ```
