# Story 5.17: Repository Performance Monitoring

## Status
- Draft

## Story
**Como** un Ingeniero de Fiabilidad de Sitios (SRE),
**quiero** que la aplicación exponga métricas de rendimiento detalladas en un formato compatible con Prometheus,
**para** poder integrar el servicio en nuestro stack de monitorización, crear dashboards en Grafana y configurar alertas proactivas sobre la latencia y las tasas de error.

## Acceptance Criteria
1.  La aplicación debe exponer un endpoint `GET /metrics` que devuelva métricas en el formato de exposición de texto de Prometheus.
2.  Se debe medir la latencia de todas las peticiones HTTP a la API, registrándola en un histograma.
3.  Se debe contar el número total de peticiones HTTP, segmentado por método, ruta y código de estado de la respuesta.
4.  Se debe medir la latencia de las operaciones críticas con las dependencias externas, como las consultas a la base de datos y las operaciones con el almacenamiento de objetos.
5.  Las métricas expuestas deben incluir etiquetas (labels) que permitan un filtrado y agregación detallados (ej: por repositorio, por tipo de operación).
6.  La recolección de métricas debe tener un impacto de rendimiento insignificante en la aplicación.

## Tasks / Subtasks
- [ ] Tarea 1: Integrar una librería de métricas de Prometheus. (AC: 1)
    - [ ] Subtarea 1.1: Añadir el crate `prometheus` a `Cargo.toml` y configurar un registro de métricas global y estático.
- [ ] Tarea 2: Definir las métricas clave de la aplicación. (AC: 2, 3, 4, 5)
    - [ ] Subtarea 2.1: Crear un módulo `metrics.rs` para definir las métricas estáticas, como `HTTP_REQUESTS_TOTAL` (CounterVec) y `HTTP_REQUEST_DURATION_SECONDS` (HistogramVec).
    - [ ] Subtarea 2.2: Añadir etiquetas (`labels`) a las métricas para dimensiones como `method`, `path`, `status_code`, y `repository`.
- [ ] Tarea 3: Implementar un middleware para la instrumentación de peticiones HTTP. (AC: 2, 3)
    - [ ] Subtarea 3.1: Crear un middleware para el framework web (Axum/Actix) que envuelva cada petición.
    - [ ] Subtarea 3.2: El middleware debe iniciar un temporizador al recibir la petición, y al finalizar, registrar la duración en el histograma e incrementar el contador con las etiquetas correspondientes.
- [ ] Tarea 4: Instrumentar los servicios internos. (AC: 4)
    - [ ] Subtarea 4.1: Crear "wrappers" o utilizar hooks en los clientes de base de datos y de almacenamiento para medir la duración de sus operaciones y registrarlas en histogramas específicos (`db_query_duration_seconds`, `storage_op_duration_seconds`).
- [ ] Tarea 5: Exponer el endpoint `/metrics`. (AC: 1)
    - [ ] Subtarea 5.1: Crear el handler para la ruta `GET /metrics`.
    - [ ] Subtarea 5.2: La implementación de este handler simplemente llamará a la función de la librería de Prometheus que codifica el registro de métricas al formato de texto.
- [ ] Tarea 6: Crear documentación para las métricas expuestas.
    - [ ] Subtarea 6.1: Crear un archivo `MONITORING.md` que liste cada métrica, su tipo (Counter, Histogram), las etiquetas que utiliza y qué significa.
- [ ] Tarea 7: Pruebas.
    - [ ] Subtarea 7.1: Probar que al realizar una petición a la API, los contadores e histogramas se actualizan correctamente.
    - [ ] Subtarea 7.2: Probar que el endpoint `/metrics` devuelve un texto bien formado y contiene las métricas actualizadas.

## Dev Notes

### Guía de Implementación y Contexto Arquitectónico

**Decisión Arquitectónica Clave: Modelo Prometheus (Scraping)**
Adoptaremos el modelo estándar de Prometheus. Nuestra aplicación es pasiva; no necesita saber a dónde enviar las métricas. Simplemente las expone en `/metrics`. Un servidor Prometheus, configurado por el equipo de SRE, será responsable de "raspar" (hacer `GET` a) este endpoint cada 15-30 segundos para recolectar los datos.

**Ejemplo de Implementación de una Métrica en Rust (usando `prometheus`):**
```rust
// en metrics.rs
use prometheus::{opts, register_histogram_vec, register_int_counter_vec, HistogramVec, IntCounterVec};
use once_cell::sync::Lazy;

pub static HTTP_REQUESTS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "http_requests_total",
        "Total number of HTTP requests.",
        &["method", "path", "status_code"]
    ).unwrap()
});

pub static HTTP_REQUEST_DURATION_SECONDS: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "http_request_duration_seconds",
        "The HTTP request latencies in seconds.",
        &["method", "path"]
    ).unwrap()
});