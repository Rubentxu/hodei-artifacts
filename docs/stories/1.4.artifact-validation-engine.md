# Story 1.4: Motor de Validación de Artefactos

## Status

Draft → Ready for MVP

## Story

**As a** Repository Administrator,
**I want** to define and enforce validation rules for incoming artifacts,
**so that** only compliant and well-formed artifacts are accepted into a repository.

## Acceptance Criteria

1. The system must provide a framework/hook to run validation rules before storage commit (pre-commit).
2. Rules can be based on artifact type, size, metadata, or content.
3. Example rules: "Block JAR files that are not signed", "Reject NPM packages with no license field".
4. The validation engine is triggered before an artifact is fully committed to storage (i.e., before persisting the physical artifact and package version).
5. If validation fails, the upload is rejected with a clear error message (400 Bad Request).
6. An `ArtifactValidationFailed` domain event must be published on failure (non-blocking if publish fails; upload still fails with 400).
7. Validation rules should be configurable per repository (phase 2); MVP may use static or in-memory rules for smoke tests.
8. Logs and traces must reflect validation execution and outcomes.

## Architectural Notes (Updated)

- Validation is part of the upload vertical slice and must not tightly couple to storage or repository details.
- The engine must be pluggable: built-in rule executors + optional policy-based executor.
- Events: on failure emit `ArtifactValidationFailed { coordinates, errors, at }`.

## Análisis: adelantar Cedar (E4) como motor de validación de reglas

Contexto: E4 define ABAC con Cedar para autorización. Estudiamos adelantar su adopción para expresar políticas de validación de artefactos (p. ej., «forbid uploadArtifact unless resource.license != null»), integrándolo en E1.F04.

Pros:
- Unificación de políticas (autorización y validación) en un mismo DSL y runtime.
- Dinamismo: reglas cambiables sin redeploy, con auditoría y versionado (alineado con E4).
- Atributos ricos: modelar condiciones por tipo de repo, entorno, horario, red, etc.
- Observabilidad: reutilizar métricas/perf de E4 (latencia p99 < 2ms por evaluación).

Contras:
- Modelado adicional: mapear contenido/metadata de artefactos a entidades Cedar y contexto.
- Complejidad de gobierno: separación de responsabilidades (validación de contenido vs. autorización de acceso).
- Performance en ruta caliente de upload: validaciones complejas podrían añadir latencia si no hay caché.
- Dependencia cruzada temprana con E4 (políticas, schema), pudiendo bloquear el avance de E1.

Alternativas en Rust (reglas/expresiones):
- Oso (Polar): más flexible y con buen debugging; coste en memoria/latencia mayor que Cedar.
- Casbin: fuerte en RBAC/ABAC, pero menos orientado a condiciones ricas sobre contenido binario/metadata.
- CEL (Common Expression Language): expresiones seguras, buenas para validar payloads; integración y tooling menos maduros que Cedar.
- JSON Schema + validadores específicos: excelente para validar manifests (`package.json`, `pom.xml` via conversión), no cubre reglas condicionales complejas multi-fuente por sí solo.
- Script engines (Rhai/Lua): flexibles pero mayor superficie de seguridad y control de sandbox.

Conclusión y decisión:
- Adoptar enfoque híbrido por fases.
  - Fase 1 (MVP en esta historia): Hook de validación pre-commit con ejecutores embebidos (p. ej. SizeLimit) y evento `ArtifactValidationFailed`. Sin dependencia dura de Cedar.
  - Fase 2: Añadir repositorio de reglas por repositorio (persistencia) y ejecutores para casos concretos (NPM license, JAR firma) con parsers dedicados.
  - Fase 3 (cuando E4 esté operativo): Prototipo de `PolicyBasedRuleExecutor` con Cedar para reglas declarativas de validación y atributos de contexto; detrás de feature flag/config.
- Justificación: desbloquea E1.F04 ya mismo, minimiza acoplamiento temprano, y deja preparada la integración con Cedar sin reescrituras.

## Scope MVP (esta entrega)

- Hook de validación integrado en el caso de uso de upload (pre-commit) con interfaz `ArtifactValidator`.
- Implementación de un validador mock/testeable + una regla simple (SizeLimit) para pruebas.
- Evento de dominio `ArtifactValidationFailed` y publicación no bloqueante en fallo de validación.
- Tests unitarios del flujo de fallo de validación (rechazo + evento + logs).

## Out of scope (futuras iteraciones)

- Motor completo de reglas con repositorio persistente.
- Ejecutores avanzados (firma JAR, `package.json` license, análisis de contenido).
- Integración Cedar como executor de validación.

## API Specifications (actualizado)
- El endpoint `POST /artifacts` invoca el hook de validación antes del commit.
- Respuesta 400 con mensaje claro si falla validación.
- Emite `ArtifactValidationFailed` (no bloquea la respuesta de error si fallara la publicación del evento).

## Tasks / Subtasks

MVP
- [ ] Definir interfaz `ArtifactValidator` en el slice de upload (hook pre-commit).
- [ ] Integrar el hook en `UploadArtifactUseCase` (ejecución al inicio).
- [ ] Añadir evento `ArtifactValidationFailed { coordinates, errors, at }` al dominio `artifact`.
- [ ] Publicar evento al fallar validación (no bloqueante si publish falla).
- [ ] Implementar `MockArtifactValidator` (tests) y una verificación simple de `SizeLimit` como ejemplo.
- [ ] Tests unitarios: éxito sin validador, fallo con validador (rechazo + evento + logs).

Fase 2
- [ ] Repositorio de reglas por repositorio (in-memory → persistente) y ejecutores específicos (NPM/JAR).

Fase 3
- [ ] Prototipo `PolicyBasedRuleExecutor` (Cedar) tras disponibilidad de E4 (ABAC), con mapping de atributos y schema.
- [ ] Métricas y tracing específicos de evaluación de reglas.

## Dev Notes

- Seguir guía de tests (TEST-ORG1): tests unitarios en archivos separados, asserts de tracing, y verificación de eventos producidos.
- No acoplar el hook a detalles de almacenamiento; mantenerlo independiente y fácil de mockear.
- La publicación del evento de validación fallida se realiza en el slice de upload para mantener el ownership del flujo.
