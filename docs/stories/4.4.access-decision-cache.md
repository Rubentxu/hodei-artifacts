# Historia 4.4: Access Decision Cache

## Estado
- **Borrador (Draft)**

## Historia
**Como** arquitecto de sistemas,
**quiero** implementar una caché de dos niveles para las decisiones de autorización,
**para que** podamos reducir la latencia de evaluación y mejorar el rendimiento general del sistema.

## Criterios de Aceptación
1.  Se crea un servicio `AccessDecisionCache`.
2.  La caché implementa una estrategia de dos niveles: una caché local en memoria (LRU) y una caché distribuida en Redis como respaldo.
3.  La caché almacena decisiones de autorización (`Allow`/`Deny`) con un Tiempo de Vida (TTL) configurable.
4.  Al solicitar una decisión, se comprueba primero la caché local (LRU). Si hay un acierto (`hit`), se devuelve el valor y se emite un evento `CacheHit`.
5.  Si hay un fallo (`miss`) en la caché local, se comprueba la caché de Redis. Si hay un acierto, el valor se almacena en la caché local y se devuelve, emitiendo un `CacheHit`.
6.  Si hay un fallo en ambas cachés, se emite un evento `CacheMiss`.
7.  Tras una evaluación de política (que resulta de un `CacheMiss`), la nueva decisión se almacena tanto en Redis (con TTL) como en la caché local, y se emite un evento `AccessDecisionCached`.
8.  El servicio de caché se suscribe a los eventos `PolicyUpdated` y `PolicyDeleted` para invalidar las entradas de caché relevantes y mantener la consistencia.

## Tareas / Subtareas
- [ ] **Tarea 1: Añadir Dependencia y Configuración**
    - [ ] Añadir la dependencia `lru = "0.10"` al `Cargo.toml` del crate de autorización.
- [ ] **Tarea 2: Definir la Clave de Caché**
    - [ ] Crear una estructura `CacheKey` que se genere de forma determinista a partir de los parámetros de una solicitud de autorización (principal, acción, recurso).
- [ ] **Tarea 3: Implementar el Servicio de Caché** (AC: #1, #2, #3)
    - [ ] Crear la estructura `AccessDecisionCache` que contenga una `LruCache` y una conexión a Redis.
- [ ] **Tarea 4: Implementar la Lógica de Lectura** (AC: #4, #5, #6)
    - [ ] Implementar el método `get_decision(&mut self, key: &CacheKey) -> Option<AccessDecision>`.
    - [ ] La implementación debe seguir el patrón de dos niveles: comprobar LRU, luego Redis.
    - [ ] Publicar los eventos `CacheHit` (para LRU o Redis) y `CacheMiss` según corresponda.
- [ ] **Tarea 5: Implementar la Lógica de Escritura** (AC: #7)
    - [ ] Implementar el método `put_decision(&mut self, key: CacheKey, decision: AccessDecision)`.
    - [ ] La implementación debe escribir en Redis con un TTL y luego en la caché LRU local.
    - [ ] Publicar el evento `AccessDecisionCached`.
- [ ] **Tarea 6: Implementar la Invalidación de Caché** (AC: #8)
    - [ ] Crear un consumidor de eventos que escuche los eventos `PolicyUpdated` y `PolicyDeleted` de la historia 4.2.
    - [ ] Implementar una estrategia de invalidación. Para empezar, una estrategia simple puede ser limpiar toda la caché local (`lru.clear()`) ante cualquier cambio de política.
- [ ] **Tarea 7: Añadir Pruebas**
    - [ ] Escribir pruebas unitarias para la lógica de la caché, cubriendo escenarios de acierto (local y Redis), fallo, expiración de TTL e invalidación.

## Notas para el Desarrollador
Esta historia implementa una optimización de rendimiento crucial. La latencia de las decisiones de autorización debe ser mínima, y una caché eficaz es la clave para lograrlo.

### Arquitectura de Caché
* La implementación debe seguir estrictamente el patrón de **"Two-Tier Caching Architecture"** detallado en la investigación técnica. El objetivo es minimizar las llamadas a la red (Redis) y, sobre todo, al costoso motor de evaluación de políticas.
    ```rust
    // Pseudocódigo de referencia para la estrategia de caché de dos niveles
    // Fuente: Investigación Técnica de la Épica E4
    struct AccessDecisionCache {
        local: LruCache<CacheKey, AccessDecision>,
        redis: RedisConnection,
        ttl: Duration,
    }

    impl AccessDecisionCache {
        async fn get_decision(&mut self, key: &CacheKey) -> Option<AccessDecision> {
            // 1. Comprobar caché local (LRU) primero
            if let Some(decision) = self.local.get(key) {
                return Some(decision.clone());
            }
            
            // 2. Comprobar caché distribuida (Redis)
            if let Ok(Some(decision)) = self.redis.get::<AccessDecision>(key).await {
                self.local.put(key.clone(), decision.clone()); // Poblar caché local
                return Some(decision);
            }
            
            None // Fallo en ambas cachés
        }
    }
    ```

### Clave de Caché (`CacheKey`)
* El diseño de la clave de caché es fundamental. Debe ser una representación única y determinista de la solicitud de autorización (p. ej., un hash del ID del principal, la acción y el ID del recurso). El pseudocódigo de `evaluate_policy` en la investigación técnica muestra el patrón `CacheKey::from_evaluation(...)`, que debe ser la inspiración.

### Invalidación de Caché
* La invalidación es la parte más compleja. La caché debe reaccionar a los cambios en las políticas (`PolicyUpdated`, `PolicyDeleted`) para evitar servir decisiones obsoletas. Una estrategia inicial simple y segura es **limpiar toda la caché local** cuando se recibe un evento de cambio de política. Se pueden explorar estrategias más granulares en el futuro si es necesario.

## Pruebas
* Las pruebas deben verificar que la secuencia de consulta (local -> distribuida) es correcta.
* Simular un cambio de política y verificar que una entrada de caché previamente válida se invalida y la siguiente solicitud resulta en un `CacheMiss`.

## Registro de Cambios
| Fecha | Versión | Descripción | Autor |
| :--- | :--- | :--- | :--- |
| 2025-09-10 | 1.0 | Borrador inicial | sm (Bob) |